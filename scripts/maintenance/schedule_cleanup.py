#!/usr/bin/env python3
"""
Scheduled cleanup script for automated repository maintenance.

This script runs both cleanup_repository.py and validate_structure.py and pushes
reports to reports/quality/ directory, extending functionality with GitHub Actions
integration, including automatic commit and PR creation for cleanup changes.
"""

import json
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

import typer
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

# Import the existing cleanup functionality
sys.path.insert(0, str(Path(__file__).parent))
try:
    from cleanup_repository import CleanupMetrics, cleanup_repository
except ImportError:
    # Fallback if cleanup_repository is not available
    CleanupMetrics = None
    cleanup_repository = None

app = typer.Typer(
    help="CLI wrapper that runs cleanup and validation scripts, generating consolidated reports.",
    add_completion=False
)
console = Console()


<<<<<<< HEAD
def run_git_command(command: List[str], cwd: Optional[Path] = None) -> tuple[bool, str]:
    """Run a git command and return success status and output."""
    try:
        result = subprocess.run(
            command,
            cwd=cwd or Path.cwd(),
            capture_output=True,
            text=True,
            check=True
        )
        return True, result.stdout.strip()
    except subprocess.CalledProcessError as e:
        return False, e.stderr.strip()


def check_git_changes() -> bool:
    """Check if there are any uncommitted changes in the repository."""
    success, output = run_git_command(["git", "status", "--porcelain"])
    return success and len(output.strip()) > 0


def commit_and_create_pr(cleanup_metrics: CleanupMetrics) -> bool:
    """Commit cleanup changes and create a pull request."""
    if not check_git_changes():
        console.print("[yellow]No changes to commit[/yellow]")
        return True
    
    # Create a unique branch name
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    branch_name = f"automated-cleanup-{timestamp}"
    
    # Create and switch to new branch
    success, output = run_git_command(["git", "checkout", "-b", branch_name])
    if not success:
        console.print(f"[red]Failed to create branch: {output}[/red]")
        return False
    
    # Add all changes
    success, output = run_git_command(["git", "add", "."])
    if not success:
        console.print(f"[red]Failed to add changes: {output}[/red]")
        return False
    
    # Create commit message
    commit_message = f"""chore: automated repository cleanup

- Files removed: {cleanup_metrics.files_removed}
- Directories removed: {cleanup_metrics.directories_removed}
- Bytes freed: {cleanup_metrics.bytes_freed:,}
- Duration: {cleanup_metrics.duration:.2f}s

Auto-generated by scheduled maintenance workflow
"""
    
    # Commit changes
    success, output = run_git_command(["git", "commit", "-m", commit_message])
    if not success:
        console.print(f"[red]Failed to commit changes: {output}[/red]")
        return False
    
    # Push branch
    success, output = run_git_command(["git", "push", "origin", branch_name])
    if not success:
        console.print(f"[red]Failed to push branch: {output}[/red]")
        return False
    
    # Create PR using GitHub CLI if available
    pr_title = f"Automated Repository Cleanup - {timestamp}"
    pr_body = f"""## Automated Repository Cleanup

This PR contains automated cleanup changes performed by the scheduled maintenance workflow.

### Cleanup Summary
- **Files removed**: {cleanup_metrics.files_removed}
- **Directories removed**: {cleanup_metrics.directories_removed}
- **Bytes freed**: {cleanup_metrics.bytes_freed:,}
- **Execution time**: {cleanup_metrics.duration:.2f}s

### Changes Made
- Removed temporary files and cache directories
- Cleaned up log files and IDE artifacts
- Removed test artifacts and build outputs

### Safe to Merge
This cleanup only removes temporary files and artifacts that are safe to delete:
- Cache directories (`__pycache__`, `.pytest_cache`, etc.)
- Temporary files (`.tmp`, `.swp`, etc.)
- Log files and debug outputs
- IDE configuration files
- Test artifacts and coverage reports

**Auto-generated by**: Scheduled maintenance workflow
**Timestamp**: {datetime.now().isoformat()}
"""
    
    # Try to create PR with GitHub CLI
    gh_command = [
        "gh", "pr", "create",
        "--title", pr_title,
        "--body", pr_body,
        "--head", branch_name,
        "--base", "main"
    ]
    
    success, output = run_git_command(gh_command)
    if success:
        console.print(f"[green]Successfully created PR: {output}[/green]")
        return True
    else:
        console.print(f"[yellow]Failed to create PR with GitHub CLI: {output}[/yellow]")
        console.print(f"[info]Branch '{branch_name}' pushed successfully. Please create PR manually.[/info]")
        return True


def generate_cleanup_report(cleaned_items: List[str], metrics: CleanupMetrics, executed: bool) -> Dict:
    """Generate a comprehensive cleanup report."""
    return {
        "timestamp": datetime.now().isoformat(),
        "executed": executed,
        "metrics": metrics.to_dict(),
        "cleaned_items": cleaned_items,
        "summary": {
            "files_removed": metrics.files_removed,
            "directories_removed": metrics.directories_removed,
            "bytes_freed": metrics.bytes_freed,
            "duration_seconds": metrics.duration,
            "errors": len(metrics.errors)
        }
    }
=======
class ScheduledCleanupResult:
    """Result container for scheduled cleanup operations."""
    
    def __init__(self) -> None:
        self.timestamp = datetime.now().isoformat()
        self.cleanup_success = False
        self.validation_success = False
        self.cleanup_report: Optional[Dict] = None
        self.validation_report: Optional[Dict] = None
        self.errors: List[str] = []
        self.duration: Optional[float] = None
    
    def to_dict(self) -> Dict:
        """Convert result to dictionary for JSON serialization."""
        return {
            "timestamp": self.timestamp,
            "duration_seconds": self.duration,
            "cleanup_success": self.cleanup_success,
            "validation_success": self.validation_success,
            "cleanup_report": self.cleanup_report,
            "validation_report": self.validation_report,
            "errors": self.errors,
            "overall_success": self.cleanup_success and self.validation_success
        }


def run_cleanup_repository(dry_run: bool = False, verbose: bool = False) -> tuple[bool, Optional[Dict]]:
    """
    Run the cleanup repository script.
    
    Args:
        dry_run: Whether to run in dry-run mode
        verbose: Whether to enable verbose output
        
    Returns:
        Tuple of (success, report_data)
    """
    script_path = Path(__file__).parent / "cleanup_repository.py"
    cmd = [sys.executable, str(script_path)]
    
    if dry_run:
        cmd.append("--dry-run")
    if verbose:
        cmd.append("--verbose")
    
    cmd.extend(["--output", "reports/quality/cleanup_report.json"])
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        
        # Load the generated report
        report_path = Path("reports/quality/cleanup_report.json")
        if report_path.exists():
            with open(report_path, 'r') as f:
                report_data = json.load(f)
            return True, report_data
        else:
            return True, None
            
    except subprocess.CalledProcessError as e:
        if verbose:
            console.print(f"[red]Cleanup failed:[/red] {e}")
            console.print(f"[red]stderr:[/red] {e.stderr}")
        return False, None
    except Exception as e:
        if verbose:
            console.print(f"[red]Unexpected error in cleanup:[/red] {e}")
        return False, None


def run_validate_structure(verbose: bool = False) -> tuple[bool, Optional[Dict]]:
    """
    Run the validate structure script.
    
    Args:
        verbose: Whether to enable verbose output
        
    Returns:
        Tuple of (success, report_data)
    """
    script_path = Path(__file__).parent / "validate_structure.py"
    cmd = [sys.executable, str(script_path)]
    
    if verbose:
        cmd.append("--verbose")
    
    cmd.extend(["--output-dir", "reports/quality"])
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        
        # Load the generated report
        report_path = Path("reports/quality/structure_validation.json")
        if report_path.exists():
            with open(report_path, 'r') as f:
                report_data = json.load(f)
            return True, report_data
        else:
            return True, None
            
    except subprocess.CalledProcessError as e:
        # Structure validation returns non-zero exit code on validation failures
        # This is expected behavior, so we still try to load the report
        report_path = Path("reports/quality/structure_validation.json")
        if report_path.exists():
            with open(report_path, 'r') as f:
                report_data = json.load(f)
            return False, report_data
        else:
            if verbose:
                console.print(f"[red]Structure validation failed:[/red] {e}")
                console.print(f"[red]stderr:[/red] {e.stderr}")
            return False, None
    except Exception as e:
        if verbose:
            console.print(f"[red]Unexpected error in structure validation:[/red] {e}")
        return False, None


def display_summary(result: ScheduledCleanupResult) -> None:
    """
    Display a summary of the scheduled cleanup results.
    
    Args:
        result: The scheduled cleanup result object
    """
    table = Table(title="Scheduled Cleanup Summary")
    table.add_column("Task", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Details", style="white")
    
    # Cleanup status
    cleanup_status = "✅ SUCCESS" if result.cleanup_success else "❌ FAILED"
    cleanup_details = ""
    if result.cleanup_report:
        metrics = result.cleanup_report.get("metrics", {})
        files_removed = metrics.get("files_removed", 0)
        dirs_removed = metrics.get("directories_removed", 0)
        cleanup_details = f"Files: {files_removed}, Dirs: {dirs_removed}"
    
    table.add_row("Repository Cleanup", cleanup_status, cleanup_details)
    
    # Validation status
    validation_status = "✅ SUCCESS" if result.validation_success else "❌ FAILED"
    validation_details = ""
    if result.validation_report:
        violations = len(result.validation_report.get("violations", []))
        validation_details = f"Violations: {violations}"
    
    table.add_row("Structure Validation", validation_status, validation_details)
    
    # Overall status
    overall_status = "✅ SUCCESS" if result.cleanup_success and result.validation_success else "❌ FAILED"
    overall_details = f"Duration: {result.duration:.2f}s" if result.duration else "N/A"
    
    table.add_row("Overall", overall_status, overall_details)
    
    console.print(table)
    
    if result.errors:
        console.print("\\n[red]Errors encountered:[/red]")
        for error in result.errors:
            console.print(f"  • {error}")
>>>>>>> origin/fix/33-critical-bug-fix


@app.command()
def main(
<<<<<<< HEAD
    execute: bool = typer.Option(False, "--execute", help="Execute cleanup and create PR if changes made"),
    dry_run: bool = typer.Option(False, "--dry-run", help="Perform a dry-run without making changes"),
    output: str = typer.Option("reports/quality/scheduled_cleanup_report.json", help="Output JSON report file"),
    verbose: bool = typer.Option(False, "--verbose", help="Enable verbose output")
):
    """
    Scheduled cleanup script for automated repository maintenance.
    
    When --execute is used, this script will:
    1. Perform repository cleanup
    2. If changes were made, commit them to a new branch
    3. Create a pull request for the cleanup changes
    4. Generate a detailed report
    """
    # Ensure we're in a git repository
    if not Path(".git").exists():
        console.print("[red]Error: Not in a git repository[/red]")
        sys.exit(1)
    
    # Create output directory
    output_path = Path(output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    if execute and dry_run:
        console.print("[red]Error: Cannot use both --execute and --dry-run[/red]")
        sys.exit(1)
    
    # Show execution mode
    if execute:
        console.print("[green]Running in EXECUTE mode - changes will be made[/green]")
    elif dry_run:
        console.print("[yellow]Running in DRY-RUN mode - no changes will be made[/yellow]")
    else:
        console.print("[yellow]Running in PREVIEW mode - no changes will be made[/yellow]")
        dry_run = True
    
    # Perform cleanup
    console.print("Starting scheduled repository cleanup...")
    
    cleaned_items, metrics = cleanup_repository(dry_run=dry_run, verbose=verbose)
    
    # Generate report
    report = generate_cleanup_report(cleaned_items, metrics, execute)
    
    # Save report
    with open(output_path, 'w') as f:
        json.dump(report, f, indent=2)
    
    # Display summary
    table = Table(title="Cleanup Summary")
    table.add_column("Metric", style="cyan")
    table.add_column("Value", style="magenta")
    
    table.add_row("Mode", "EXECUTE" if execute else "DRY-RUN")
    table.add_row("Files Removed", str(metrics.files_removed))
    table.add_row("Directories Removed", str(metrics.directories_removed))
    table.add_row("Bytes Freed", f"{metrics.bytes_freed:,}")
    table.add_row("Duration", f"{metrics.duration:.2f}s")
    table.add_row("Errors", str(len(metrics.errors)))
    
    console.print(table)
    
    # If executing and changes were made, create PR
    if execute and cleaned_items:
        console.print("\n[green]Changes detected, creating pull request...[/green]")
        if commit_and_create_pr(metrics):
            console.print("[green]✅ Cleanup completed successfully with PR created[/green]")
        else:
            console.print("[red]❌ Failed to create PR, but cleanup was successful[/red]")
            sys.exit(1)
    elif execute:
        console.print("\n[info]No changes were made during cleanup[/info]")
    
    # Print errors if any
    if metrics.errors:
        console.print("\n[red]Errors encountered during cleanup:[/red]")
        for error in metrics.errors:
            console.print(f"  • {error}")
    
    console.print(f"\n[info]Report saved to: {output_path}[/info]")
    
    # Exit with appropriate code
    if metrics.errors:
        sys.exit(1)
    else:
=======
    dry_run: bool = typer.Option(False, "--dry-run", "-d", help="Run cleanup in dry-run mode"),
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Enable verbose output"),
    output: str = typer.Option("reports/quality/scheduled_cleanup_report.json", "--output", "-o", help="Output consolidated report file"),
    skip_cleanup: bool = typer.Option(False, "--skip-cleanup", help="Skip repository cleanup"),
    skip_validation: bool = typer.Option(False, "--skip-validation", help="Skip structure validation")
) -> None:
    """
    Run scheduled cleanup and validation tasks.
    
    This tool runs both the repository cleanup and structure validation scripts,
    generating consolidated reports in the reports/quality/ directory.
    
    Examples:
        # Run full cleanup and validation
        python schedule_cleanup.py
        
        # Run in dry-run mode
        python schedule_cleanup.py --dry-run
        
        # Run only cleanup
        python schedule_cleanup.py --skip-validation
        
        # Run only validation
        python schedule_cleanup.py --skip-cleanup
    """
    console.print("[bold blue]🔧 Scheduled Cleanup & Validation[/bold blue]")
    console.print("")
    
    result = ScheduledCleanupResult()
    start_time = datetime.now()
    
    # Ensure output directory exists
    output_path = Path(output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
        transient=True
    ) as progress:
        
        if not skip_cleanup:
            task = progress.add_task("Running repository cleanup...", total=None)
            cleanup_success, cleanup_report = run_cleanup_repository(dry_run=dry_run, verbose=verbose)
            result.cleanup_success = cleanup_success
            result.cleanup_report = cleanup_report
            
            if not cleanup_success:
                result.errors.append("Repository cleanup failed")
        else:
            result.cleanup_success = True  # Skip counts as success
            
        if not skip_validation:
            task = progress.add_task("Running structure validation...", total=None)
            validation_success, validation_report = run_validate_structure(verbose=verbose)
            result.validation_success = validation_success
            result.validation_report = validation_report
            
            if not validation_success:
                result.errors.append("Structure validation failed")
        else:
            result.validation_success = True  # Skip counts as success
    
    end_time = datetime.now()
    result.duration = (end_time - start_time).total_seconds()
    
    # Display summary
    display_summary(result)
    
    # Save consolidated report
    try:
        with open(output_path, 'w') as f:
            json.dump(result.to_dict(), f, indent=2)
        console.print(f"\\n[green]Consolidated report saved to:[/green] {output_path}")
    except OSError as e:
        console.print(f"[red]Failed to save consolidated report:[/red] {e}")
        sys.exit(1)
    
    # Exit with appropriate code
    if not (result.cleanup_success and result.validation_success):
        console.print(f"\\n[red]Scheduled cleanup completed with errors[/red]")
        sys.exit(1)
    else:
        console.print("\\n[green]Scheduled cleanup completed successfully[/green]")
>>>>>>> origin/fix/33-critical-bug-fix
        sys.exit(0)


if __name__ == "__main__":
    app()
