#!/usr/bin/env python3
"""
Scheduled cleanup script for automated repository maintenance.

This script extends the repository cleanup functionality with GitHub Actions
integration, including automatic commit and PR creation for cleanup changes.
"""

import json
import os
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

import typer
from rich.console import Console
from rich.table import Table

# Import the existing cleanup functionality
sys.path.insert(0, str(Path(__file__).parent))
from cleanup_repository import cleanup_repository, CleanupMetrics

app = typer.Typer(
    help="Scheduled cleanup script for automated repository maintenance.",
    add_completion=False
)
console = Console()


def run_git_command(command: List[str], cwd: Optional[Path] = None) -> tuple[bool, str]:
    """Run a git command and return success status and output."""
    try:
        result = subprocess.run(
            command,
            cwd=cwd or Path.cwd(),
            capture_output=True,
            text=True,
            check=True
        )
        return True, result.stdout.strip()
    except subprocess.CalledProcessError as e:
        return False, e.stderr.strip()


def check_git_changes() -> bool:
    """Check if there are any uncommitted changes in the repository."""
    success, output = run_git_command(["git", "status", "--porcelain"])
    return success and len(output.strip()) > 0


def commit_and_create_pr(cleanup_metrics: CleanupMetrics) -> bool:
    """Commit cleanup changes and create a pull request."""
    if not check_git_changes():
        console.print("[yellow]No changes to commit[/yellow]")
        return True
    
    # Create a unique branch name
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    branch_name = f"automated-cleanup-{timestamp}"
    
    # Create and switch to new branch
    success, output = run_git_command(["git", "checkout", "-b", branch_name])
    if not success:
        console.print(f"[red]Failed to create branch: {output}[/red]")
        return False
    
    # Add all changes
    success, output = run_git_command(["git", "add", "."])
    if not success:
        console.print(f"[red]Failed to add changes: {output}[/red]")
        return False
    
    # Create commit message
    commit_message = f"""chore: automated repository cleanup

- Files removed: {cleanup_metrics.files_removed}
- Directories removed: {cleanup_metrics.directories_removed}
- Bytes freed: {cleanup_metrics.bytes_freed:,}
- Duration: {cleanup_metrics.duration:.2f}s

Auto-generated by scheduled maintenance workflow
"""
    
    # Commit changes
    success, output = run_git_command(["git", "commit", "-m", commit_message])
    if not success:
        console.print(f"[red]Failed to commit changes: {output}[/red]")
        return False
    
    # Push branch
    success, output = run_git_command(["git", "push", "origin", branch_name])
    if not success:
        console.print(f"[red]Failed to push branch: {output}[/red]")
        return False
    
    # Create PR using GitHub CLI if available
    pr_title = f"Automated Repository Cleanup - {timestamp}"
    pr_body = f"""## Automated Repository Cleanup

This PR contains automated cleanup changes performed by the scheduled maintenance workflow.

### Cleanup Summary
- **Files removed**: {cleanup_metrics.files_removed}
- **Directories removed**: {cleanup_metrics.directories_removed}
- **Bytes freed**: {cleanup_metrics.bytes_freed:,}
- **Execution time**: {cleanup_metrics.duration:.2f}s

### Changes Made
- Removed temporary files and cache directories
- Cleaned up log files and IDE artifacts
- Removed test artifacts and build outputs

### Safe to Merge
This cleanup only removes temporary files and artifacts that are safe to delete:
- Cache directories (`__pycache__`, `.pytest_cache`, etc.)
- Temporary files (`.tmp`, `.swp`, etc.)
- Log files and debug outputs
- IDE configuration files
- Test artifacts and coverage reports

**Auto-generated by**: Scheduled maintenance workflow
**Timestamp**: {datetime.now().isoformat()}
"""
    
    # Try to create PR with GitHub CLI
    gh_command = [
        "gh", "pr", "create",
        "--title", pr_title,
        "--body", pr_body,
        "--head", branch_name,
        "--base", "main"
    ]
    
    success, output = run_git_command(gh_command)
    if success:
        console.print(f"[green]Successfully created PR: {output}[/green]")
        return True
    else:
        console.print(f"[yellow]Failed to create PR with GitHub CLI: {output}[/yellow]")
        console.print(f"[info]Branch '{branch_name}' pushed successfully. Please create PR manually.[/info]")
        return True


def generate_cleanup_report(cleaned_items: List[str], metrics: CleanupMetrics, executed: bool) -> Dict:
    """Generate a comprehensive cleanup report."""
    return {
        "timestamp": datetime.now().isoformat(),
        "executed": executed,
        "metrics": metrics.to_dict(),
        "cleaned_items": cleaned_items,
        "summary": {
            "files_removed": metrics.files_removed,
            "directories_removed": metrics.directories_removed,
            "bytes_freed": metrics.bytes_freed,
            "duration_seconds": metrics.duration,
            "errors": len(metrics.errors)
        }
    }


@app.command()
def main(
    execute: bool = typer.Option(False, "--execute", help="Execute cleanup and create PR if changes made"),
    dry_run: bool = typer.Option(False, "--dry-run", help="Perform a dry-run without making changes"),
    output: str = typer.Option("reports/quality/scheduled_cleanup_report.json", help="Output JSON report file"),
    verbose: bool = typer.Option(False, "--verbose", help="Enable verbose output")
):
    """
    Scheduled cleanup script for automated repository maintenance.
    
    When --execute is used, this script will:
    1. Perform repository cleanup
    2. If changes were made, commit them to a new branch
    3. Create a pull request for the cleanup changes
    4. Generate a detailed report
    """
    # Ensure we're in a git repository
    if not Path(".git").exists():
        console.print("[red]Error: Not in a git repository[/red]")
        sys.exit(1)
    
    # Create output directory
    output_path = Path(output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    if execute and dry_run:
        console.print("[red]Error: Cannot use both --execute and --dry-run[/red]")
        sys.exit(1)
    
    # Show execution mode
    if execute:
        console.print("[green]Running in EXECUTE mode - changes will be made[/green]")
    elif dry_run:
        console.print("[yellow]Running in DRY-RUN mode - no changes will be made[/yellow]")
    else:
        console.print("[yellow]Running in PREVIEW mode - no changes will be made[/yellow]")
        dry_run = True
    
    # Perform cleanup
    console.print("Starting scheduled repository cleanup...")
    
    cleaned_items, metrics = cleanup_repository(dry_run=dry_run, verbose=verbose)
    
    # Generate report
    report = generate_cleanup_report(cleaned_items, metrics, execute)
    
    # Save report
    with open(output_path, 'w') as f:
        json.dump(report, f, indent=2)
    
    # Display summary
    table = Table(title="Cleanup Summary")
    table.add_column("Metric", style="cyan")
    table.add_column("Value", style="magenta")
    
    table.add_row("Mode", "EXECUTE" if execute else "DRY-RUN")
    table.add_row("Files Removed", str(metrics.files_removed))
    table.add_row("Directories Removed", str(metrics.directories_removed))
    table.add_row("Bytes Freed", f"{metrics.bytes_freed:,}")
    table.add_row("Duration", f"{metrics.duration:.2f}s")
    table.add_row("Errors", str(len(metrics.errors)))
    
    console.print(table)
    
    # If executing and changes were made, create PR
    if execute and cleaned_items:
        console.print("\n[green]Changes detected, creating pull request...[/green]")
        if commit_and_create_pr(metrics):
            console.print("[green]✅ Cleanup completed successfully with PR created[/green]")
        else:
            console.print("[red]❌ Failed to create PR, but cleanup was successful[/red]")
            sys.exit(1)
    elif execute:
        console.print("\n[info]No changes were made during cleanup[/info]")
    
    # Print errors if any
    if metrics.errors:
        console.print("\n[red]Errors encountered during cleanup:[/red]")
        for error in metrics.errors:
            console.print(f"  • {error}")
    
    console.print(f"\n[info]Report saved to: {output_path}[/info]")
    
    # Exit with appropriate code
    if metrics.errors:
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    app()
