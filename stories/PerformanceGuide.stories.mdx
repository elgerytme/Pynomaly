import { Meta } from '@storybook/addon-docs';

<Meta title="Guidelines/Performance" />

# Performance Best Practices

Optimizing Pynomaly for exceptional performance across all devices and network conditions. Our performance strategy focuses on **Core Web Vitals**, efficient data handling, and responsive user interfaces.

## 🎯 Core Web Vitals Targets

### Performance Metrics
- **Largest Contentful Paint (LCP)**: < 2.5 seconds
- **First Input Delay (FID)**: < 100 milliseconds  
- **Cumulative Layout Shift (CLS)**: < 0.1
- **First Contentful Paint (FCP)**: < 1.8 seconds
- **Time to Interactive (TTI)**: < 3.5 seconds

### Performance Budget
```javascript
// Bundle size limits
const performanceBudget = {
  'main.js': '150KB',        // Core application bundle
  'vendor.js': '300KB',      // Third-party libraries
  'charts.js': '100KB',      // Chart visualization bundle
  'workers.js': '50KB',      // Service worker and web workers
  'total-js': '600KB',       // Total JavaScript
  'css': '100KB',            // Total CSS
  'images': '500KB',         // Image assets
  'fonts': '200KB'           // Font files
};
```

## 🚀 Loading Performance

### Critical Resource Optimization
```html
<!-- Preload critical resources -->
<link rel="preload" href="/fonts/inter-var.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/css/critical.css" as="style">
<link rel="preload" href="/js/main.js" as="script">

<!-- DNS prefetch for external resources -->
<link rel="dns-prefetch" href="//api.pynomaly.com">
<link rel="dns-prefetch" href="//cdn.pynomaly.com">

<!-- Resource hints for next page navigation -->
<link rel="prefetch" href="/dashboard">
<link rel="preconnect" href="/api/ws" crossorigin>
```

### Code Splitting Strategy
```javascript
// Route-based code splitting
const Dashboard = lazy(() => import('./components/Dashboard'));
const Analytics = lazy(() => import('./components/Analytics'));
const Settings = lazy(() => import('./components/Settings'));

// Feature-based splitting
const ChartEngine = lazy(() => 
  import('./charts/ChartEngine').then(module => ({ 
    default: module.ChartEngine 
  }))
);

// Conditional loading for heavy features
const AdvancedAnalytics = lazy(() => {
  if (userRole === 'analyst' || userRole === 'admin') {
    return import('./components/AdvancedAnalytics');
  }
  return Promise.resolve({ default: () => null });
});
```

### Progressive Enhancement
```javascript
// Service worker registration with performance monitoring
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/sw.js');
      
      // Monitor service worker performance
      performance.mark('sw-registered');
      console.log('SW registered:', registration);
      
    } catch (error) {
      console.warn('SW registration failed:', error);
    }
  });
}
```

## 📊 Chart Performance

### Efficient Data Handling
```javascript
// Virtual scrolling for large datasets
class VirtualizedChart {
  constructor(container, data) {
    this.container = container;
    this.data = data;
    this.viewportSize = 1000;  // Render only visible items
    this.bufferSize = 100;     // Extra items for smooth scrolling
  }
  
  getVisibleData(scrollTop, viewportHeight) {
    const startIndex = Math.max(0, 
      Math.floor(scrollTop / this.itemHeight) - this.bufferSize
    );
    const endIndex = Math.min(this.data.length,
      startIndex + this.viewportSize + (2 * this.bufferSize)
    );
    
    return {
      data: this.data.slice(startIndex, endIndex),
      startIndex,
      endIndex
    };
  }
}

// Debounced updates for real-time charts
const debouncedUpdate = useMemo(
  () => debounce((newData) => {
    requestAnimationFrame(() => {
      chart.setData(newData);
    });
  }, 16), // ~60 FPS
  [chart]
);

// Efficient data aggregation
function aggregateDataPoints(data, timeWindow = '5min') {
  const aggregated = new Map();
  
  data.forEach(point => {
    const timeKey = roundToWindow(point.timestamp, timeWindow);
    
    if (!aggregated.has(timeKey)) {
      aggregated.set(timeKey, {
        timestamp: timeKey,
        values: [],
        count: 0
      });
    }
    
    const bucket = aggregated.get(timeKey);
    bucket.values.push(point.value);
    bucket.count++;
  });
  
  return Array.from(aggregated.values()).map(bucket => ({
    timestamp: bucket.timestamp,
    value: bucket.values.reduce((a, b) => a + b, 0) / bucket.count,
    count: bucket.count,
    min: Math.min(...bucket.values),
    max: Math.max(...bucket.values)
  }));
}
```

### Canvas Optimization
```javascript
// High-performance canvas rendering
class OptimizedCanvasChart {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.dpr = window.devicePixelRatio || 1;
    this.animationId = null;
    this.isDirty = false;
    
    this.setupCanvas();
    this.setupAnimationLoop();
  }
  
  setupCanvas() {
    const rect = this.canvas.getBoundingClientRect();
    
    // Set actual size in memory (scaled to account for extra pixel density)
    this.canvas.width = rect.width * this.dpr;
    this.canvas.height = rect.height * this.dpr;
    
    // Scale the canvas back down using CSS
    this.canvas.style.width = rect.width + 'px';
    this.canvas.style.height = rect.height + 'px';
    
    // Scale the drawing context to match device pixel ratio
    this.ctx.scale(this.dpr, this.dpr);
  }
  
  setupAnimationLoop() {
    const animate = () => {
      if (this.isDirty) {
        this.render();
        this.isDirty = false;
      }
      this.animationId = requestAnimationFrame(animate);
    };
    animate();
  }
  
  render() {
    // Clear with efficient method
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Batch drawing operations
    this.ctx.save();
    this.drawBackground();
    this.drawDataPoints();
    this.drawAxes();
    this.ctx.restore();
  }
  
  invalidate() {
    this.isDirty = true;
  }
  
  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}
```

## 💾 Memory Management

### Efficient State Management
```javascript
// Immutable updates with structural sharing
function updateStateEfficiently(state, update) {
  // Use libraries like Immer for efficient immutable updates
  return produce(state, draft => {
    // Only update changed properties
    Object.assign(draft.data, update);
  });
}

// Memory-conscious data structures
class RingBuffer {
  constructor(capacity) {
    this.buffer = new Array(capacity);
    this.capacity = capacity;
    this.size = 0;
    this.head = 0;
  }
  
  push(item) {
    this.buffer[this.head] = item;
    this.head = (this.head + 1) % this.capacity;
    
    if (this.size < this.capacity) {
      this.size++;
    }
  }
  
  toArray() {
    const result = new Array(this.size);
    for (let i = 0; i < this.size; i++) {
      result[i] = this.buffer[(this.head - this.size + i + this.capacity) % this.capacity];
    }
    return result;
  }
}

// Automatic cleanup for subscriptions
class ComponentWithCleanup extends Component {
  constructor(props) {
    super(props);
    this.subscriptions = new Set();
  }
  
  addSubscription(subscription) {
    this.subscriptions.add(subscription);
  }
  
  componentWillUnmount() {
    // Automatic cleanup to prevent memory leaks
    this.subscriptions.forEach(unsub => unsub());
    this.subscriptions.clear();
  }
}
```

### Image and Asset Optimization
```javascript
// Lazy loading with Intersection Observer
class LazyImageLoader {
  constructor() {
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      { rootMargin: '50px 0px' }
    );
  }
  
  observe(img) {
    this.observer.observe(img);
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.onload = () => img.classList.add('loaded');
        this.observer.unobserve(img);
      }
    });
  }
}

// Progressive image loading
function createProgressiveImage(src, placeholder) {
  const img = new Image();
  img.src = placeholder; // Low-quality placeholder
  
  const highRes = new Image();
  highRes.onload = () => {
    img.src = highRes.src;
    img.classList.add('high-res-loaded');
  };
  highRes.src = src;
  
  return img;
}
```

## 🌐 Network Performance

### Efficient API Calls
```javascript
// Request deduplication
class APIClient {
  constructor() {
    this.cache = new Map();
    this.pendingRequests = new Map();
  }
  
  async get(url, options = {}) {
    const cacheKey = `${url}-${JSON.stringify(options)}`;
    
    // Return cached response if available
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    // Return pending request if in flight
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey);
    }
    
    // Make new request
    const request = fetch(url, {
      ...options,
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json',
        ...options.headers
      }
    })
    .then(response => response.json())
    .then(data => {
      this.cache.set(cacheKey, data);
      this.pendingRequests.delete(cacheKey);
      return data;
    })
    .catch(error => {
      this.pendingRequests.delete(cacheKey);
      throw error;
    });
    
    this.pendingRequests.set(cacheKey, request);
    return request;
  }
}

// Batch API requests
class BatchProcessor {
  constructor(batchSize = 10, delay = 100) {
    this.batchSize = batchSize;
    this.delay = delay;
    this.queue = [];
    this.timeoutId = null;
  }
  
  add(request) {
    this.queue.push(request);
    
    if (this.queue.length >= this.batchSize) {
      this.flush();
    } else if (!this.timeoutId) {
      this.timeoutId = setTimeout(() => this.flush(), this.delay);
    }
  }
  
  flush() {
    if (this.queue.length === 0) return;
    
    const batch = this.queue.splice(0, this.batchSize);
    clearTimeout(this.timeoutId);
    this.timeoutId = null;
    
    // Send batch request
    fetch('/api/batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ requests: batch })
    });
  }
}
```

### WebSocket Optimization
```javascript
// Efficient WebSocket data handling
class OptimizedWebSocket {
  constructor(url) {
    this.url = url;
    this.ws = null;
    this.messageQueue = [];
    this.isConnected = false;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    
    this.connect();
  }
  
  connect() {
    this.ws = new WebSocket(this.url);
    
    this.ws.onopen = () => {
      this.isConnected = true;
      this.reconnectAttempts = 0;
      
      // Send queued messages
      while (this.messageQueue.length > 0) {
        this.ws.send(this.messageQueue.shift());
      }
    };
    
    this.ws.onmessage = (event) => {
      // Use efficient JSON parsing for large messages
      const data = event.data;
      if (data.length > 10000) {
        // Parse in next tick to avoid blocking
        setTimeout(() => {
          this.handleMessage(JSON.parse(data));
        }, 0);
      } else {
        this.handleMessage(JSON.parse(data));
      }
    };
    
    this.ws.onclose = () => {
      this.isConnected = false;
      this.attemptReconnect();
    };
  }
  
  send(message) {
    const serialized = JSON.stringify(message);
    
    if (this.isConnected) {
      this.ws.send(serialized);
    } else {
      this.messageQueue.push(serialized);
    }
  }
  
  attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
      
      setTimeout(() => {
        this.reconnectAttempts++;
        this.connect();
      }, delay);
    }
  }
}
```

## 🔍 Performance Monitoring

### Real-Time Performance Tracking
```javascript
// Performance metrics collection
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.observers = new Map();
    
    this.setupObservers();
  }
  
  setupObservers() {
    // Largest Contentful Paint
    if ('PerformanceObserver' in window) {
      const lcpObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        this.recordMetric('LCP', lastEntry.startTime);
      });
      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
      
      // First Input Delay
      const fidObserver = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          this.recordMetric('FID', entry.processingStart - entry.startTime);
        });
      });
      fidObserver.observe({ entryTypes: ['first-input'] });
      
      // Cumulative Layout Shift
      const clsObserver = new PerformanceObserver((list) => {
        let clsValue = 0;
        list.getEntries().forEach((entry) => {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
          }
        });
        this.recordMetric('CLS', clsValue);
      });
      clsObserver.observe({ entryTypes: ['layout-shift'] });
    }
  }
  
  recordMetric(name, value) {
    this.metrics.set(name, {
      value,
      timestamp: performance.now()
    });
    
    // Send to analytics if threshold exceeded
    this.checkThresholds(name, value);
  }
  
  checkThresholds(name, value) {
    const thresholds = {
      'LCP': 2500,  // 2.5 seconds
      'FID': 100,   // 100 milliseconds
      'CLS': 0.1    // 0.1 cumulative score
    };
    
    if (thresholds[name] && value > thresholds[name]) {
      console.warn(`Performance threshold exceeded: ${name} = ${value}`);
      
      // Send to monitoring service
      this.sendMetricToAnalytics(name, value);
    }
  }
  
  sendMetricToAnalytics(name, value) {
    // Send performance data to analytics service
    fetch('/api/analytics/performance', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        metric: name,
        value: value,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
      })
    }).catch(error => {
      console.warn('Failed to send performance metric:', error);
    });
  }
}

// Initialize performance monitoring
const performanceMonitor = new PerformanceMonitor();
```

### Bundle Analysis
```javascript
// Webpack Bundle Analyzer configuration
module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      reportFilename: 'bundle-report.html',
      openAnalyzer: false
    })
  ],
  
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        charts: {
          test: /[\\/]charts[\\/]/,
          name: 'charts',
          chunks: 'all',
          priority: 10
        }
      }
    }
  }
};
```

## 📱 Mobile Performance

### Touch Optimization
```css
/* Optimize touch responsiveness */
.interactive-element {
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}

/* Reduce paint and layout thrashing */
.animated-element {
  will-change: transform;
  transform: translateZ(0); /* Force hardware acceleration */
}

/* Efficient scrolling */
.scrollable-container {
  -webkit-overflow-scrolling: touch;
  scroll-behavior: smooth;
}
```

### Responsive Image Strategy
```html
<!-- Responsive images with performance optimization -->
<picture>
  <source 
    media="(max-width: 480px)" 
    srcset="chart-small.webp 480w, chart-small@2x.webp 960w"
    type="image/webp">
  <source 
    media="(max-width: 480px)" 
    srcset="chart-small.jpg 480w, chart-small@2x.jpg 960w">
  <source 
    media="(max-width: 1024px)" 
    srcset="chart-medium.webp 1024w, chart-medium@2x.webp 2048w"
    type="image/webp">
  <source 
    media="(max-width: 1024px)" 
    srcset="chart-medium.jpg 1024w, chart-medium@2x.jpg 2048w">
  <source 
    srcset="chart-large.webp 1920w, chart-large@2x.webp 3840w"
    type="image/webp">
  <img 
    src="chart-large.jpg" 
    srcset="chart-large.jpg 1920w, chart-large@2x.jpg 3840w"
    sizes="(max-width: 480px) 100vw, (max-width: 1024px) 100vw, 1920px"
    alt="Anomaly detection chart"
    loading="lazy"
    decoding="async">
</picture>
```

## 🌠 Performance Testing

### Automated Performance Testing
```javascript
// Lighthouse CI configuration
module.exports = {
  ci: {
    collect: {
      url: [
        'http://localhost:3000/',
        'http://localhost:3000/dashboard',
        'http://localhost:3000/analytics'
      ],
      numberOfRuns: 3
    },
    assert: {
      assertions: {
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['error', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.8 }]
      }
    },
    upload: {
      target: 'lhci',
      serverBaseUrl: 'https://lhci.example.com'
    }
  }
};

// Jest performance tests
describe('Performance Tests', () => {
  it('should load dashboard within performance budget', async () => {
    const startTime = performance.now();
    
    render(<Dashboard />);
    
    await waitFor(() => {
      expect(screen.getByRole('main')).toBeInTheDocument();
    });
    
    const loadTime = performance.now() - startTime;
    expect(loadTime).toBeLessThan(3000); // 3 second budget
  });
  
  it('should handle large datasets efficiently', async () => {
    const largeDataset = generateTestData(10000);
    const startTime = performance.now();
    
    render(<Chart data={largeDataset} />);
    
    const renderTime = performance.now() - startTime;
    expect(renderTime).toBeLessThan(500); // 500ms budget
  });
});
```

## 🛠️ Performance Tools

### Development Tools
- **Lighthouse**: Automated performance auditing
- **WebPageTest**: Real-world performance testing
- **Chrome DevTools**: Performance profiling and analysis
- **Bundle Analyzer**: JavaScript bundle optimization

### Monitoring Tools
- **Core Web Vitals**: Google's performance metrics
- **Real User Monitoring (RUM)**: Production performance tracking
- **Synthetic Monitoring**: Automated performance testing
- **Performance Observer API**: Browser performance measurement

---

*Performance is a feature. Every millisecond matters for user experience and business success.*