"""
Template service for creating and managing custom report templates.

This service provides:
- Template creation and management
- Dynamic layout configuration
- Template rendering and customization
- Template sharing and versioning
"""

import json
import logging
import uuid
from dataclasses import asdict, dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

import pandas as pd
from jinja2 import Environment, FileSystemLoader

from anomaly_detection.shared.exceptions import TemplateError, ValidationError


@dataclass
class TemplateConfig:
    """Configuration for report templates."""

    template_id: str
    name: str
    description: str
    format_type: str  # excel, pdf, html, json, etc.
    version: str = "1.0"
    created_at: datetime | None = None
    updated_at: datetime | None = None
    author: str | None = None
    tags: list[str] = None

    # Layout configuration
    layout: dict[str, Any] = None
    sections: list[dict[str, Any]] = None
    styling: dict[str, Any] = None

    # Data configuration
    data_filters: dict[str, Any] = None
    data_transformations: list[dict[str, Any]] = None

    # Export configuration
    export_options: dict[str, Any] | None = None

    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        if self.updated_at is None:
            self.updated_at = self.created_at
        if self.tags is None:
            self.tags = []
        if self.layout is None:
            self.layout = self._default_layout()
        if self.sections is None:
            self.sections = self._default_sections()
        if self.styling is None:
            self.styling = self._default_styling()
        if self.data_filters is None:
            self.data_filters = {}
        if self.data_transformations is None:
            self.data_transformations = []
        if self.export_options is None:
            self.export_options = {}

    def _default_layout(self) -> dict[str, Any]:
        """Default layout configuration."""
        return {
            "orientation": "portrait",
            "page_size": "A4",
            "margins": {"top": 1, "bottom": 1, "left": 1, "right": 1},
            "header_height": 0.75,
            "footer_height": 0.5,
            "columns": 1,
        }

    def _default_sections(self) -> list[dict[str, Any]]:
        """Default sections configuration."""
        return [
            {
                "type": "header",
                "title": "Anomaly Detection Report",
                "subtitle": "Generated by Pynomaly",
                "include_timestamp": True,
                "include_logo": False,
            },
            {
                "type": "summary",
                "title": "Executive Summary",
                "include_metrics": True,
                "include_charts": True,
                "metrics": ["total_records", "anomalies_detected", "anomaly_rate"],
            },
            {
                "type": "data_table",
                "title": "Anomaly Results",
                "include_all_columns": False,
                "columns": ["timestamp", "anomaly_score", "is_anomaly", "confidence"],
                "sort_by": "anomaly_score",
                "sort_order": "desc",
                "max_rows": 1000,
            },
            {
                "type": "visualizations",
                "title": "Data Visualizations",
                "charts": [
                    {
                        "type": "histogram",
                        "column": "anomaly_score",
                        "title": "Score Distribution",
                    },
                    {
                        "type": "timeline",
                        "x": "timestamp",
                        "y": "anomaly_score",
                        "title": "Anomaly Timeline",
                    },
                ],
            },
            {
                "type": "footer",
                "include_pagination": True,
                "include_generation_time": True,
                "custom_text": "",
            },
        ]

    def _default_styling(self) -> dict[str, Any]:
        """Default styling configuration."""
        return {
            "font_family": "Arial",
            "font_size": 11,
            "header_font_size": 16,
            "title_font_size": 14,
            "colors": {
                "primary": "#2E86AB",
                "secondary": "#A23B72",
                "accent": "#F18F01",
                "background": "#FFFFFF",
                "text": "#333333",
                "anomaly_high": "#FF6B6B",
                "anomaly_medium": "#FFE66D",
                "anomaly_low": "#4ECDC4",
            },
            "table": {
                "header_background": "#F0F0F0",
                "alternate_row_background": "#F8F8F8",
                "border_color": "#CCCCCC",
                "border_width": 1,
            },
        }


class TemplateService:
    """Service for managing custom report templates."""

    def __init__(self, templates_dir: str | None = None):
        """Initialize template service."""
        self.logger = logging.getLogger(__name__)
        self.templates_dir = Path(templates_dir) if templates_dir else Path("templates")
        self.templates_dir.mkdir(exist_ok=True)

        # Initialize Jinja2 environment
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.templates_dir)), autoescape=True
        )

        # Template registry
        self._templates: dict[str, TemplateConfig] = {}
        self._load_templates()

    def create_template(
        self, name: str, description: str, format_type: str, **kwargs
    ) -> TemplateConfig:
        """Create a new custom template."""
        try:
            template_id = kwargs.get("template_id", str(uuid.uuid4()))

            # Validate format type
            supported_formats = [
                "excel",
                "pdf",
                "html",
                "json",
                "csv",
                "powerbi",
                "google_sheets",
                "smartsheet",
            ]
            if format_type not in supported_formats:
                raise ValidationError(f"Unsupported format type: {format_type}")

            # Create template configuration
            template_config = TemplateConfig(
                template_id=template_id,
                name=name,
                description=description,
                format_type=format_type,
                **kwargs,
            )

            # Save template
            self._save_template(template_config)

            # Register template
            self._templates[template_id] = template_config

            self.logger.info(f"Created template: {name} ({template_id})")
            return template_config

        except Exception as e:
            raise TemplateError(f"Failed to create template: {str(e)}") from e

    def get_template(self, template_id: str) -> TemplateConfig | None:
        """Get template by ID."""
        return self._templates.get(template_id)

    def list_templates(
        self, format_type: str | None = None, tags: list[str] | None = None
    ) -> list[TemplateConfig]:
        """List available templates with optional filtering."""
        templates = list(self._templates.values())

        if format_type:
            templates = [t for t in templates if t.format_type == format_type]

        if tags:
            templates = [t for t in templates if any(tag in t.tags for tag in tags)]

        return sorted(templates, key=lambda t: t.updated_at, reverse=True)

    def update_template(self, template_id: str, **updates) -> TemplateConfig:
        """Update an existing template."""
        try:
            template = self._templates.get(template_id)
            if not template:
                raise ValidationError(f"Template not found: {template_id}")

            # Update fields
            for key, value in updates.items():
                if hasattr(template, key):
                    setattr(template, key, value)

            template.updated_at = datetime.now()

            # Save updated template
            self._save_template(template)

            self.logger.info(f"Updated template: {template.name} ({template_id})")
            return template

        except Exception as e:
            raise TemplateError(f"Failed to update template: {str(e)}") from e

    def delete_template(self, template_id: str) -> bool:
        """Delete a template."""
        try:
            if template_id not in self._templates:
                return False

            # Remove template file
            template_file = self.templates_dir / f"{template_id}.json"
            if template_file.exists():
                template_file.unlink()

            # Remove from registry
            del self._templates[template_id]

            self.logger.info(f"Deleted template: {template_id}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to delete template {template_id}: {str(e)}")
            return False

    def render_template(
        self,
        template_id: str,
        data: pd.DataFrame | list[dict[str, Any]],
        context: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        """Render template with data."""
        try:
            template_config = self.get_template(template_id)
            if not template_config:
                raise ValidationError(f"Template not found: {template_id}")

            # Convert data to DataFrame if needed
            if isinstance(data, list):
                df = pd.DataFrame(data)
            else:
                df = data.copy()

            # Apply data filters
            filtered_df = self._apply_data_filters(df, template_config.data_filters)

            # Apply data transformations
            transformed_df = self._apply_data_transformations(
                filtered_df, template_config.data_transformations
            )

            # Generate sections
            sections = self._generate_sections(transformed_df, template_config, context)

            # Calculate metrics
            metrics = self._calculate_metrics(transformed_df)

            return {
                "template_id": template_id,
                "template_name": template_config.name,
                "format_type": template_config.format_type,
                "sections": sections,
                "metrics": metrics,
                "data": transformed_df.to_dict("records"),
                "styling": template_config.styling,
                "layout": template_config.layout,
                "timestamp": datetime.now().isoformat(),
            }

        except Exception as e:
            raise TemplateError(f"Failed to render template: {str(e)}") from e

    def _apply_data_filters(
        self, df: pd.DataFrame, filters: dict[str, Any]
    ) -> pd.DataFrame:
        """Apply data filters to DataFrame."""
        filtered_df = df.copy()

        for column, filter_config in filters.items():
            if column not in df.columns:
                continue

            filter_type = filter_config.get("type", "equal")
            value = filter_config.get("value")

            if filter_type == "equal":
                filtered_df = filtered_df[filtered_df[column] == value]
            elif filter_type == "greater_than":
                filtered_df = filtered_df[filtered_df[column] > value]
            elif filter_type == "less_than":
                filtered_df = filtered_df[filtered_df[column] < value]
            elif filter_type == "between":
                min_val, max_val = value
                filtered_df = filtered_df[
                    (filtered_df[column] >= min_val) & (filtered_df[column] <= max_val)
                ]
            elif filter_type == "in":
                filtered_df = filtered_df[filtered_df[column].isin(value)]
            elif filter_type == "not_null":
                filtered_df = filtered_df[filtered_df[column].notna()]

        return filtered_df

    def _apply_data_transformations(
        self, df: pd.DataFrame, transformations: list[dict[str, Any]]
    ) -> pd.DataFrame:
        """Apply data transformations to DataFrame."""
        transformed_df = df.copy()

        for transform in transformations:
            transform_type = transform.get("type")

            if transform_type == "sort":
                column = transform.get("column")
                order = transform.get("order", "asc")
                if column in transformed_df.columns:
                    ascending = order == "asc"
                    transformed_df = transformed_df.sort_values(
                        column, ascending=ascending
                    )

            elif transform_type == "limit":
                limit = transform.get("limit", 1000)
                transformed_df = transformed_df.head(limit)

            elif transform_type == "aggregate":
                group_by = transform.get("group_by")
                agg_column = transform.get("column")
                agg_function = transform.get("function", "mean")

                def both_in_df(col1: str, col2: str, df: pd.DataFrame) -> bool:
                    return col1 in df.columns and col2 in df.columns

                if (
                    group_by
                    and agg_column
                    and both_in_df(group_by, agg_column, transformed_df)
                ):
                    transformed_df = (
                        transformed_df.groupby(group_by)[agg_column]
                        .agg(agg_function)
                        .reset_index()
                    )

            elif transform_type == "add_column":
                column_name = transform.get("name")
                expression = transform.get("expression")

                if column_name and expression:
                    # Simple expression evaluation (extend as needed)
                    if expression == "row_number":
                        transformed_df[column_name] = range(1, len(transformed_df) + 1)
                    elif expression == "current_timestamp":
                        transformed_df[column_name] = datetime.now()

        return transformed_df

    def both_in_df(self, col1: str, col2: str, df: pd.DataFrame) -> bool:
        """Check if both columns exist in DataFrame."""
        return col1 in df.columns and col2 in df.columns

    def _generate_sections(
        self,
        df: pd.DataFrame,
        template_config: TemplateConfig,
        context: dict[str, Any] | None,
    ) -> list[dict[str, Any]]:
        """Generate report sections based on template configuration."""
        sections = []

        for section_config in template_config.sections:
            section_type = section_config.get("type")

            if section_type == "header":
                sections.append(self._generate_header_section(section_config, context))
            elif section_type == "summary":
                sections.append(self._generate_summary_section(df, section_config))
            elif section_type == "data_table":
                sections.append(self._generate_data_table_section(df, section_config))
            elif section_type == "visualizations":
                sections.append(
                    self._generate_visualizations_section(df, section_config)
                )
            elif section_type == "footer":
                sections.append(self._generate_footer_section(section_config, context))

        return sections

    def _generate_header_section(
        self, config: dict[str, Any], context: dict[str, Any] | None
    ) -> dict[str, Any]:
        """Generate header section."""
        section = {
            "type": "header",
            "title": config.get("title", "Report"),
            "subtitle": config.get("subtitle", ""),
            "content": {},
        }

        if config.get("include_timestamp", True):
            section["content"]["timestamp"] = datetime.now().strftime(
                "%Y-%m-%d %H:%M:%S"
            )

        if config.get("include_logo", False):
            section["content"]["logo_path"] = config.get("logo_path", "")

        if context:
            section["content"]["context"] = context

        return section

    def _generate_summary_section(
        self, df: pd.DataFrame, config: dict[str, Any]
    ) -> dict[str, Any]:
        """Generate summary section with metrics."""
        metrics = self._calculate_metrics(df)

        section = {
            "type": "summary",
            "title": config.get("title", "Summary"),
            "content": {
                "metrics": metrics,
                "text": self._generate_summary_text(metrics),
            },
        }

        if config.get("include_charts", True):
            section["content"]["charts"] = self._generate_summary_charts(df)

        return section

    def _generate_data_table_section(
        self, df: pd.DataFrame, config: dict[str, Any]
    ) -> dict[str, Any]:
        """Generate data table section."""
        # Select columns
        if config.get("include_all_columns", False):
            columns = df.columns.tolist()
        else:
            columns = config.get("columns", df.columns.tolist()[:5])
            columns = [col for col in columns if col in df.columns]

        # Sort data
        table_df = df[columns].copy()
        if config.get("sort_by") and config["sort_by"] in table_df.columns:
            ascending = config.get("sort_order", "asc") == "asc"
            table_df = table_df.sort_values(config["sort_by"], ascending=ascending)

        # Limit rows
        max_rows = config.get("max_rows", 1000)
        table_df = table_df.head(max_rows)

        return {
            "type": "data_table",
            "title": config.get("title", "Data"),
            "content": {
                "headers": columns,
                "rows": table_df.values.tolist(),
                "total_rows": len(df),
                "displayed_rows": len(table_df),
            },
        }

    def _generate_visualizations_section(
        self, df: pd.DataFrame, config: dict[str, Any]
    ) -> dict[str, Any]:
        """Generate visualizations section."""
        charts = []

        for chart_config in config.get("charts", []):
            chart_type = chart_config.get("type")

            if chart_type == "histogram" and chart_config.get("column") in df.columns:
                charts.append(
                    {
                        "type": "histogram",
                        "title": chart_config.get("title", "Histogram"),
                        "data": df[chart_config["column"]].dropna().tolist(),
                        "column": chart_config["column"],
                    }
                )

            elif chart_type == "timeline" and all(
                col in df.columns
                for col in [chart_config.get("x"), chart_config.get("y")]
            ):
                charts.append(
                    {
                        "type": "timeline",
                        "title": chart_config.get("title", "Timeline"),
                        "x_data": df[chart_config["x"]].tolist(),
                        "y_data": df[chart_config["y"]].tolist(),
                        "x_label": chart_config["x"],
                        "y_label": chart_config["y"],
                    }
                )

        return {
            "type": "visualizations",
            "title": config.get("title", "Visualizations"),
            "content": {"charts": charts},
        }

    def _generate_footer_section(
        self, config: dict[str, Any], context: dict[str, Any] | None
    ) -> dict[str, Any]:
        """Generate footer section."""
        content = {}

        if config.get("include_generation_time", True):
            content["generation_time"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        if config.get("include_pagination", True):
            content["pagination"] = True

        custom_text = config.get("custom_text", "")
        if custom_text:
            content["custom_text"] = custom_text

        return {"type": "footer", "content": content}

    def _calculate_metrics(self, df: pd.DataFrame) -> dict[str, Any]:
        """Calculate summary metrics from data."""
        metrics = {
            "total_records": len(df),
            "columns": len(df.columns),
            "data_types": df.dtypes.to_dict(),
        }

        if "anomaly_score" in df.columns:
            anomaly_scores = pd.to_numeric(df["anomaly_score"], errors="coerce")
            metrics.update(
                {
                    "anomalies_detected": len(df[anomaly_scores > 0.5]),
                    "anomaly_rate": len(df[anomaly_scores > 0.5]) / len(df) * 100
                    if len(df) > 0
                    else 0,
                    "avg_anomaly_score": anomaly_scores.mean(),
                    "max_anomaly_score": anomaly_scores.max(),
                    "min_anomaly_score": anomaly_scores.min(),
                }
            )

        if "timestamp" in df.columns:
            timestamps = pd.to_datetime(df["timestamp"], errors="coerce")
            metrics.update(
                {
                    "time_range": {
                        "start": timestamps.min().isoformat()
                        if not timestamps.isna().all()
                        else None,
                        "end": timestamps.max().isoformat()
                        if not timestamps.isna().all()
                        else None,
                    }
                }
            )

        return metrics

    def _generate_summary_text(self, metrics: dict[str, Any]) -> str:
        """Generate summary text from metrics."""
        total_records = metrics.get("total_records", 0)
        anomalies = metrics.get("anomalies_detected", 0)
        anomaly_rate = metrics.get("anomaly_rate", 0)

        text = f"This report contains {total_records} records. "

        if anomalies > 0:
            text += (
                f"{anomalies} anomalies were detected "
                f"({anomaly_rate:.2f}% anomaly rate). "
            )
        else:
            text += "No anomalies were detected. "

        return text

    def _generate_summary_charts(self, df: pd.DataFrame) -> list[dict[str, Any]]:
        """Generate summary charts."""
        charts = []

        if "anomaly_score" in df.columns:
            charts.append(
                {
                    "type": "summary_histogram",
                    "title": "Anomaly Score Distribution",
                    "data": df["anomaly_score"].dropna().tolist(),
                }
            )

        return charts

    def _load_templates(self) -> None:
        """Load templates from disk."""
        try:
            for template_file in self.templates_dir.glob("*.json"):
                with open(template_file) as f:
                    data = json.load(f)
                    template_config = TemplateConfig(**data)
                    self._templates[template_config.template_id] = template_config

            self.logger.info(f"Loaded {len(self._templates)} templates")

        except Exception as e:
            self.logger.error(f"Failed to load templates: {str(e)}")

    def _save_template(self, template_config: TemplateConfig) -> None:
        """Save template to disk."""
        template_file = self.templates_dir / f"{template_config.template_id}.json"

        # Convert dataclass to dict, handling datetime serialization
        data = asdict(template_config)
        data["created_at"] = template_config.created_at.isoformat()
        data["updated_at"] = template_config.updated_at.isoformat()

        with open(template_file, "w") as f:
            json.dump(data, f, indent=2)

    def create_predefined_templates(self) -> list[TemplateConfig]:
        """Create a set of predefined templates for common use cases."""
        predefined_templates = [
            {
                "name": "Executive Summary",
                "description": "High-level summary report for executives",
                "format_type": "pdf",
                "tags": ["executive", "summary"],
                "sections": [
                    {"type": "header", "title": "Executive Anomaly Report"},
                    {"type": "summary", "include_charts": True},
                    {"type": "footer"},
                ],
            },
            {
                "name": "Technical Details",
                "description": "Detailed technical report with full data",
                "format_type": "excel",
                "tags": ["technical", "detailed"],
                "sections": [
                    {"type": "header", "title": "Technical Anomaly Analysis"},
                    {"type": "summary"},
                    {"type": "data_table", "include_all_columns": True},
                    {"type": "visualizations"},
                    {"type": "footer"},
                ],
            },
            {
                "name": "Real-time Dashboard",
                "description": "Real-time dashboard template for monitoring",
                "format_type": "html",
                "tags": ["dashboard", "realtime"],
                "sections": [
                    {"type": "header", "title": "Real-time Anomaly Dashboard"},
                    {"type": "summary", "include_charts": True},
                    {"type": "visualizations"},
                ],
            },
        ]

        created_templates = []
        for template_data in predefined_templates:
            try:
                template = self.create_template(**template_data)
                created_templates.append(template)
            except Exception as e:
                self.logger.error(
                    f"Failed to create predefined template {template_data['name']}: "
                    f"{str(e)}"
                )

        return created_templates
