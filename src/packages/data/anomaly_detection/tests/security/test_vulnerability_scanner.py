"""Tests for vulnerability scanner framework."""

import asyncio
import json
import pytest
from datetime import datetime
from unittest.mock import AsyncMock, Mock, patch, mock_open
from pathlib import Path

from anomaly_detection.application.services.security.vulnerability_scanner import (
    VulnerabilityScanner,
    DependencyScanner,
    CodeAnalysisScanner,
    APISecurityScanner,
    VulnerabilityFinding,
    VulnerabilitySeverity,
    VulnerabilityCategory,
    ScanResult
)


@pytest.mark.security
class TestVulnerabilityScanner:
    """Test vulnerability scanner functionality."""
    
    def setup_method(self):
        """Set up test fixtures."""
        self.config = {
            "dependency": {"enabled": True},
            "code_analysis": {"enabled": True},
            "api_security": {"enabled": True, "base_url": "http://localhost:8000"}
        }
        self.scanner = VulnerabilityScanner(self.config)
    
    @pytest.mark.asyncio
    async def test_comprehensive_scan(self):
        """Test comprehensive vulnerability scan."""
        target = "/test/project"
        
        # Mock scanner results
        with patch.object(self.scanner.scanners["dependency"], "scan", new_callable=AsyncMock) as mock_dep, \
             patch.object(self.scanner.scanners["code_analysis"], "scan", new_callable=AsyncMock) as mock_code, \
             patch.object(self.scanner.scanners["api_security"], "scan", new_callable=AsyncMock) as mock_api:
            
            # Configure mock returns
            mock_dep.return_value = [
                VulnerabilityFinding(
                    id="dep_001",
                    title="Vulnerable dependency",
                    description="Test vulnerability",
                    severity=VulnerabilitySeverity.HIGH,
                    category=VulnerabilityCategory.DEPENDENCIES
                )
            ]
            
            mock_code.return_value = [
                VulnerabilityFinding(
                    id="code_001",
                    title="Code vulnerability",
                    description="Test code issue",
                    severity=VulnerabilitySeverity.MEDIUM,
                    category=VulnerabilityCategory.INJECTION
                )
            ]
            
            mock_api.return_value = [
                VulnerabilityFinding(
                    id="api_001",
                    title="API vulnerability",
                    description="Test API issue",
                    severity=VulnerabilitySeverity.CRITICAL,
                    category=VulnerabilityCategory.AUTHENTICATION
                )
            ]
            
            # Run scan
            result = await self.scanner.scan_all(target)
            
            # Verify results
            assert isinstance(result, ScanResult)
            assert result.target == target
            assert len(result.findings) == 3
            assert len(result.critical_findings) == 1
            assert len(result.high_findings) == 1
            assert result.total_checks == 3
            
            # Verify scanners were called
            mock_dep.assert_called_once_with(target)
            mock_code.assert_called_once_with(target)
            mock_api.assert_called_once_with(target)
    
    @pytest.mark.asyncio
    async def test_selective_scan(self):
        """Test selective scanner execution."""
        target = "/test/project"
        scan_types = ["dependency", "code_analysis"]
        
        with patch.object(self.scanner.scanners["dependency"], "scan", new_callable=AsyncMock) as mock_dep, \
             patch.object(self.scanner.scanners["code_analysis"], "scan", new_callable=AsyncMock) as mock_code, \
             patch.object(self.scanner.scanners["api_security"], "scan", new_callable=AsyncMock) as mock_api:
            
            mock_dep.return_value = []
            mock_code.return_value = []
            mock_api.return_value = []
            
            result = await self.scanner.scan_all(target, scan_types=scan_types)
            
            # Verify only selected scanners were called
            mock_dep.assert_called_once()
            mock_code.assert_called_once()
            mock_api.assert_not_called()
            
            assert result.total_checks == 2
    
    def test_generate_report(self):
        """Test vulnerability report generation."""
        findings = [
            VulnerabilityFinding(
                id="test_001",
                title="Critical Issue",
                description="Critical vulnerability",
                severity=VulnerabilitySeverity.CRITICAL,
                category=VulnerabilityCategory.INJECTION,
                confidence=0.9
            ),
            VulnerabilityFinding(
                id="test_002",
                title="High Issue",
                description="High vulnerability",
                severity=VulnerabilitySeverity.HIGH,
                category=VulnerabilityCategory.AUTHENTICATION,
                confidence=0.8
            )
        ]
        
        scan_result = ScanResult(
            scan_id="test_scan",
            scan_type="test",
            start_time=datetime.utcnow(),
            end_time=datetime.utcnow(),
            target="/test",
            findings=findings,
            scan_duration=10.0,
            total_checks=2,
            passed_checks=0,
            failed_checks=2
        )
        
        report = self.scanner.generate_report(scan_result)
        
        # Verify report structure
        assert "scan_info" in report
        assert "summary" in report
        assert "findings_by_severity" in report
        assert "findings_by_category" in report
        assert "recommendations" in report
        
        # Verify summary
        summary = report["summary"]
        assert summary["total_findings"] == 2
        assert summary["critical_findings"] == 1
        assert summary["high_findings"] == 1
        assert summary["risk_score"] > 0
        
        # Verify findings by severity
        assert "critical" in report["findings_by_severity"]
        assert "high" in report["findings_by_severity"]
        assert len(report["findings_by_severity"]["critical"]) == 1
        assert len(report["findings_by_severity"]["high"]) == 1
        
        # Verify findings by category
        assert report["findings_by_category"]["injection"] == 1
        assert report["findings_by_category"]["authentication"] == 1
        
        # Verify recommendations
        assert len(report["recommendations"]) > 0
    
    def test_risk_score_calculation(self):
        """Test risk score calculation."""
        # Test empty findings
        assert self.scanner._calculate_risk_score([]) == 0.0
        
        # Test mixed severity findings
        findings = [
            VulnerabilityFinding(
                id="1", title="Critical", description="", 
                severity=VulnerabilitySeverity.CRITICAL,
                category=VulnerabilityCategory.INJECTION,
                confidence=1.0
            ),
            VulnerabilityFinding(
                id="2", title="High", description="",
                severity=VulnerabilitySeverity.HIGH,
                category=VulnerabilityCategory.AUTHENTICATION,
                confidence=0.8
            ),
            VulnerabilityFinding(
                id="3", title="Low", description="",
                severity=VulnerabilitySeverity.LOW,
                category=VulnerabilityCategory.CONFIGURATION,
                confidence=0.5
            )
        ]
        
        risk_score = self.scanner._calculate_risk_score(findings)
        assert 0 <= risk_score <= 100
        assert risk_score > 50  # Should be high due to critical finding


@pytest.mark.security
class TestDependencyScanner:
    """Test dependency vulnerability scanner."""
    
    def setup_method(self):
        """Set up test fixtures."""
        self.scanner = DependencyScanner()
    
    @pytest.mark.asyncio
    async def test_pip_audit_scan(self):
        """Test pip-audit scanning."""
        mock_output = {
            "vulnerabilities": [
                {
                    "id": "PYSEC-2023-001",
                    "package": "requests",
                    "installed_version": "2.25.0",
                    "fixed_version": "2.25.1",
                    "description": "Test vulnerability",
                    "severity": "high",
                    "cvss_score": 7.5,
                    "advisory_url": "https://example.com/advisory"
                }
            ]
        }
        
        with patch('asyncio.create_subprocess_exec') as mock_exec:
            # Mock process
            mock_process = Mock()
            mock_process.communicate.return_value = (
                json.dumps(mock_output).encode(),
                b""
            )
            mock_process.returncode = 0
            mock_exec.return_value = mock_process
            
            findings = await self.scanner._scan_with_pip_audit("/test/requirements.txt")
            
            assert len(findings) == 1
            finding = findings[0]
            assert finding.title == "Vulnerable dependency: requests"
            assert finding.severity == VulnerabilitySeverity.HIGH
            assert finding.category == VulnerabilityCategory.DEPENDENCIES
            assert finding.affected_component == "requests"
            assert finding.cvss_score == 7.5
    
    @pytest.mark.asyncio
    async def test_safety_scan(self):
        """Test safety scanning."""
        mock_output = [
            {
                "id": "12345",
                "package_name": "django",
                "installed_version": "2.2.0",
                "advisory": "Django vulnerability description"
            }
        ]
        
        with patch('asyncio.create_subprocess_exec') as mock_exec:
            mock_process = Mock()
            mock_process.communicate.return_value = (
                json.dumps(mock_output).encode(),
                b""
            )
            mock_process.returncode = 0
            mock_exec.return_value = mock_process
            
            findings = await self.scanner._scan_with_safety("/test/requirements.txt")
            
            assert len(findings) == 1
            finding = findings[0]
            assert finding.title == "Safety vulnerability: django"
            assert finding.severity == VulnerabilitySeverity.HIGH
            assert finding.category == VulnerabilityCategory.DEPENDENCIES
            assert finding.affected_component == "django"
    
    def test_severity_mapping(self):
        """Test severity mapping functionality."""
        assert self.scanner._map_severity("critical") == VulnerabilitySeverity.CRITICAL
        assert self.scanner._map_severity("high") == VulnerabilitySeverity.HIGH
        assert self.scanner._map_severity("medium") == VulnerabilitySeverity.MEDIUM
        assert self.scanner._map_severity("low") == VulnerabilitySeverity.LOW
        assert self.scanner._map_severity("unknown") == VulnerabilitySeverity.MEDIUM


@pytest.mark.security
class TestCodeAnalysisScanner:
    """Test code analysis vulnerability scanner."""
    
    def setup_method(self):
        """Set up test fixtures."""
        self.scanner = CodeAnalysisScanner()
    
    @pytest.mark.asyncio
    async def test_bandit_scan(self):
        """Test bandit code scanning."""
        mock_output = {
            "results": [
                {
                    "test_id": "B101",
                    "test_name": "assert_used",
                    "issue_text": "Use of assert detected",
                    "issue_severity": "LOW",
                    "issue_confidence": "HIGH",
                    "filename": "/test/file.py",
                    "line_number": 42,
                    "code": "assert user.is_admin",
                    "cwe": {"id": "CWE-703"}
                }
            ]
        }
        
        with patch('asyncio.create_subprocess_exec') as mock_exec:
            mock_process = Mock()
            mock_process.communicate.return_value = (
                json.dumps(mock_output).encode(),
                b""
            )
            mock_process.returncode = 0
            mock_exec.return_value = mock_process
            
            findings = await self.scanner._scan_with_bandit("/test/code")
            
            assert len(findings) == 1
            finding = findings[0]
            assert finding.title == "Bandit: assert_used"
            assert finding.severity == VulnerabilitySeverity.LOW
            assert finding.file_path == "/test/file.py"
            assert finding.line_number == 42
            assert finding.evidence == "assert user.is_admin"
            assert finding.confidence == 0.9  # HIGH confidence
            assert finding.cwe_id == "CWE-703"
    
    @pytest.mark.asyncio
    async def test_semgrep_scan(self):
        """Test semgrep code scanning."""
        mock_output = {
            "results": [
                {
                    "check_id": "python.lang.security.injection.sql-injection",
                    "message": "Possible SQL injection vulnerability",
                    "severity": "ERROR",
                    "path": "/test/file.py",
                    "start": {"line": 10},
                    "extra": {"lines": "cursor.execute(f'SELECT * FROM users WHERE id = {user_id}')"
                    }
                }
            ]
        }
        
        with patch('asyncio.create_subprocess_exec') as mock_exec:
            mock_process = Mock()
            mock_process.communicate.return_value = (
                json.dumps(mock_output).encode(),
                b""
            )
            mock_process.returncode = 0
            mock_exec.return_value = mock_process
            
            findings = await self.scanner._scan_with_semgrep("/test/code")
            
            assert len(findings) == 1
            finding = findings[0]
            assert finding.title == "Semgrep: python.lang.security.injection.sql-injection"
            assert finding.severity == VulnerabilitySeverity.HIGH  # ERROR -> HIGH
            assert finding.category == VulnerabilityCategory.INJECTION
            assert finding.file_path == "/test/file.py"
            assert finding.line_number == 10
    
    def test_bandit_severity_mapping(self):
        """Test bandit severity mapping."""
        assert self.scanner._map_bandit_severity("HIGH") == VulnerabilitySeverity.HIGH
        assert self.scanner._map_bandit_severity("MEDIUM") == VulnerabilitySeverity.MEDIUM
        assert self.scanner._map_bandit_severity("LOW") == VulnerabilitySeverity.LOW
    
    def test_bandit_confidence_mapping(self):
        """Test bandit confidence mapping."""
        assert self.scanner._map_bandit_confidence("HIGH") == 0.9
        assert self.scanner._map_bandit_confidence("MEDIUM") == 0.6
        assert self.scanner._map_bandit_confidence("LOW") == 0.3
    
    def test_semgrep_categorization(self):
        """Test semgrep rule categorization."""
        assert self.scanner._categorize_semgrep_rule("python.lang.security.injection.sql") == VulnerabilityCategory.INJECTION
        assert self.scanner._categorize_semgrep_rule("python.lang.security.crypto.weak-hash") == VulnerabilityCategory.CRYPTOGRAPHY
        assert self.scanner._categorize_semgrep_rule("python.lang.security.auth.jwt") == VulnerabilityCategory.AUTHENTICATION
        assert self.scanner._categorize_semgrep_rule("python.lang.security.input.validation") == VulnerabilityCategory.INPUT_VALIDATION


@pytest.mark.security
class TestAPISecurityScanner:
    """Test API security vulnerability scanner."""
    
    def setup_method(self):
        """Set up test fixtures."""
        config = {"base_url": "http://localhost:8000", "timeout": 10}
        self.scanner = APISecurityScanner(config)
    
    @pytest.mark.asyncio
    async def test_authentication_bypass_detection(self):
        """Test authentication bypass vulnerability detection."""
        with patch('httpx.AsyncClient') as mock_client:
            mock_client_instance = Mock()
            mock_client.return_value.__aenter__.return_value = mock_client_instance
            
            # Mock successful response without auth (vulnerability)
            mock_response = Mock()
            mock_response.status_code = 200
            mock_client_instance.post.return_value = mock_response
            
            findings = await self.scanner._test_authentication_bypass()
            
            # Should detect auth bypass for endpoints that return 200
            assert len(findings) > 0
            
            # Check one finding
            finding = findings[0]
            assert finding.severity == VulnerabilitySeverity.HIGH
            assert finding.category == VulnerabilityCategory.AUTHENTICATION
            assert "Authentication bypass" in finding.title
    
    @pytest.mark.asyncio
    async def test_input_validation_testing(self):
        """Test input validation vulnerability detection."""
        with patch('httpx.AsyncClient') as mock_client:
            mock_client_instance = Mock()
            mock_client.return_value.__aenter__.return_value = mock_client_instance
            
            # Mock server error response (potential vulnerability)
            mock_response = Mock()
            mock_response.status_code = 500
            mock_response.text = "Internal Server Error: Exception occurred"
            mock_client_instance.post.return_value = mock_response
            
            findings = await self.scanner._test_input_validation()
            
            # Should detect input validation issues
            assert len(findings) > 0
            
            finding = findings[0]
            assert finding.severity == VulnerabilitySeverity.HIGH
            assert finding.category == VulnerabilityCategory.INJECTION
            assert "injection" in finding.title.lower()
    
    @pytest.mark.asyncio
    async def test_rate_limiting_detection(self):
        """Test rate limiting vulnerability detection."""
        with patch('httpx.AsyncClient') as mock_client:
            mock_client_instance = Mock()
            mock_client.return_value.__aenter__.return_value = mock_client_instance
            
            # Mock many successful responses (no rate limiting)
            mock_response = Mock()
            mock_response.status_code = 200
            mock_client_instance.post.return_value = mock_response
            
            findings = await self.scanner._test_rate_limiting()
            
            # Should detect missing rate limiting
            assert len(findings) > 0
            
            finding = findings[0]
            assert finding.severity == VulnerabilitySeverity.MEDIUM
            assert finding.category == VulnerabilityCategory.DENIAL_OF_SERVICE
            assert "rate limiting" in finding.title.lower()
    
    @pytest.mark.asyncio
    async def test_information_disclosure_detection(self):
        """Test information disclosure vulnerability detection."""
        with patch('httpx.AsyncClient') as mock_client:
            mock_client_instance = Mock()
            mock_client.return_value.__aenter__.return_value = mock_client_instance
            
            # Mock response with sensitive information
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.text = '{"api_key": "secret123", "data": "normal"}'
            mock_client_instance.get.return_value = mock_response
            
            findings = await self.scanner._test_information_disclosure()
            
            # Should detect information disclosure
            assert len(findings) > 0
            
            finding = findings[0]
            assert finding.severity == VulnerabilitySeverity.MEDIUM
            assert finding.category == VulnerabilityCategory.DATA_EXPOSURE
            assert "Information disclosure" in finding.title


@pytest.mark.security
class TestVulnerabilityFinding:
    """Test vulnerability finding data structure."""
    
    def test_finding_creation(self):
        """Test vulnerability finding creation."""
        finding = VulnerabilityFinding(
            id="test_001",
            title="Test Vulnerability",
            description="Test description",
            severity=VulnerabilitySeverity.HIGH,
            category=VulnerabilityCategory.INJECTION,
            cwe_id="CWE-89",
            cvss_score=7.5,
            affected_component="api/users",
            file_path="/test/file.py",
            line_number=42,
            evidence="SELECT * FROM users",
            remediation="Use parameterized queries",
            references=["https://example.com/cve"],
            confidence=0.8
        )
        
        assert finding.id == "test_001"
        assert finding.title == "Test Vulnerability"
        assert finding.severity == VulnerabilitySeverity.HIGH
        assert finding.category == VulnerabilityCategory.INJECTION
        assert finding.cwe_id == "CWE-89"
        assert finding.cvss_score == 7.5
        assert finding.confidence == 0.8
        assert isinstance(finding.timestamp, datetime)


@pytest.mark.security
class TestScanResult:
    """Test scan result data structure."""
    
    def test_scan_result_properties(self):
        """Test scan result calculated properties."""
        findings = [
            VulnerabilityFinding(
                id="1", title="Critical", description="",
                severity=VulnerabilitySeverity.CRITICAL,
                category=VulnerabilityCategory.INJECTION
            ),
            VulnerabilityFinding(
                id="2", title="High", description="",
                severity=VulnerabilitySeverity.HIGH,
                category=VulnerabilityCategory.AUTHENTICATION
            ),
            VulnerabilityFinding(
                id="3", title="Medium", description="",
                severity=VulnerabilitySeverity.MEDIUM,
                category=VulnerabilityCategory.CONFIGURATION
            )
        ]
        
        result = ScanResult(
            scan_id="test",
            scan_type="test",
            start_time=datetime.utcnow(),
            end_time=datetime.utcnow(),
            target="/test",
            findings=findings,
            scan_duration=10.0,
            total_checks=5,
            passed_checks=2,
            failed_checks=3
        )
        
        assert result.success_rate == 0.4  # 2/5
        assert len(result.critical_findings) == 1
        assert len(result.high_findings) == 1
        
        # Test empty findings
        empty_result = ScanResult(
            scan_id="empty",
            scan_type="test",
            start_time=datetime.utcnow(),
            end_time=datetime.utcnow(),
            target="/test",
            findings=[],
            scan_duration=1.0,
            total_checks=0,
            passed_checks=0,
            failed_checks=0
        )
        
        assert empty_result.success_rate == 0.0
        assert len(empty_result.critical_findings) == 0
        assert len(empty_result.high_findings) == 0


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s", "--tb=short"])