"""Comprehensive vulnerability scanning and security testing framework."""

from __future__ import annotations

import asyncio
import hashlib
import json
import re
import subprocess
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union
from urllib.parse import urlparse

import httpx
import numpy as np
from pydantic import BaseModel, validator

from ....domain.entities.detection_result import DetectionResult
from ....infrastructure.logging import get_logger
from ....infrastructure.monitoring import get_metrics_collector

logger = get_logger(__name__)
metrics_collector = get_metrics_collector()


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityCategory(Enum):
    """Vulnerability categories."""
    INJECTION = "injection"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    CRYPTOGRAPHY = "cryptography"
    INPUT_VALIDATION = "input_validation"
    CONFIGURATION = "configuration"
    DEPENDENCIES = "dependencies"
    DATA_EXPOSURE = "data_exposure"
    DENIAL_OF_SERVICE = "denial_of_service"
    BUSINESS_LOGIC = "business_logic"


@dataclass
class VulnerabilityFinding:
    """Individual vulnerability finding."""
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    category: VulnerabilityCategory
    cwe_id: Optional[str] = None
    cvss_score: Optional[float] = None
    affected_component: Optional[str] = None
    file_path: Optional[str] = None
    line_number: Optional[int] = None
    evidence: Optional[str] = None
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.utcnow)
    confidence: float = 1.0  # 0.0 to 1.0


@dataclass
class ScanResult:
    """Vulnerability scan result."""
    scan_id: str
    scan_type: str
    start_time: datetime
    end_time: datetime
    target: str
    findings: List[VulnerabilityFinding]
    scan_duration: float
    total_checks: int
    passed_checks: int
    failed_checks: int
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def success_rate(self) -> float:
        """Calculate scan success rate."""
        if self.total_checks == 0:
            return 0.0
        return self.passed_checks / self.total_checks

    @property
    def critical_findings(self) -> List[VulnerabilityFinding]:
        """Get critical severity findings."""
        return [f for f in self.findings if f.severity == VulnerabilitySeverity.CRITICAL]

    @property
    def high_findings(self) -> List[VulnerabilityFinding]:
        """Get high severity findings."""
        return [f for f in self.findings if f.severity == VulnerabilitySeverity.HIGH]


class BaseScanner(ABC):
    """Base class for vulnerability scanners."""

    def __init__(self, name: str, config: Optional[Dict[str, Any]] = None):
        self.name = name
        self.config = config or {}
        self.enabled = self.config.get("enabled", True)

    @abstractmethod
    async def scan(self, target: str, **kwargs) -> List[VulnerabilityFinding]:
        """Perform vulnerability scan."""
        pass

    def generate_finding_id(self, component: str, vulnerability_type: str) -> str:
        """Generate unique finding ID."""
        timestamp = str(int(time.time()))
        content = f"{self.name}_{component}_{vulnerability_type}_{timestamp}"
        return hashlib.md5(content.encode()).hexdigest()[:12]


class DependencyScanner(BaseScanner):
    """Scanner for dependency vulnerabilities using safety and pip-audit."""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("dependency_scanner", config)
        self.safety_db_path = self.config.get("safety_db_path")

    async def scan(self, target: str, **kwargs) -> List[VulnerabilityFinding]:
        """Scan for dependency vulnerabilities."""
        findings = []
        
        # Scan with pip-audit
        pip_audit_findings = await self._scan_with_pip_audit(target)
        findings.extend(pip_audit_findings)
        
        # Scan with safety
        safety_findings = await self._scan_with_safety(target)
        findings.extend(safety_findings)
        
        return findings

    async def _scan_with_pip_audit(self, target: str) -> List[VulnerabilityFinding]:
        """Scan dependencies with pip-audit."""
        findings = []
        
        try:
            # Run pip-audit command
            process = await asyncio.create_subprocess_exec(
                "pip-audit", "--format", "json", "--requirement", target,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                results = json.loads(stdout.decode())
                
                for vuln in results.get("vulnerabilities", []):
                    finding = VulnerabilityFinding(
                        id=self.generate_finding_id("dependency", vuln["id"]),
                        title=f"Vulnerable dependency: {vuln['package']}",
                        description=vuln.get("description", "No description available"),
                        severity=self._map_severity(vuln.get("severity", "medium")),
                        category=VulnerabilityCategory.DEPENDENCIES,
                        affected_component=vuln["package"],
                        evidence=f"Version {vuln.get('installed_version')} affected",
                        remediation=f"Upgrade to version {vuln.get('fixed_version', 'latest')}",
                        cvss_score=vuln.get("cvss_score"),
                        references=[vuln.get("advisory_url", "")]
                    )
                    findings.append(finding)
            
        except Exception as e:
            logger.error("pip-audit scan failed", error=str(e))
            
        return findings

    async def _scan_with_safety(self, target: str) -> List[VulnerabilityFinding]:
        """Scan dependencies with safety."""
        findings = []
        
        try:
            cmd = ["safety", "check", "--json", "--file", target]
            if self.safety_db_path:
                cmd.extend(["--db", self.safety_db_path])
                
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if stdout:
                try:
                    results = json.loads(stdout.decode())
                    
                    for vuln in results:
                        finding = VulnerabilityFinding(
                            id=self.generate_finding_id("dependency", vuln["id"]),
                            title=f"Safety vulnerability: {vuln['package_name']}",
                            description=vuln.get("advisory", "No description available"),
                            severity=VulnerabilitySeverity.HIGH,  # Safety typically reports high severity
                            category=VulnerabilityCategory.DEPENDENCIES,
                            affected_component=vuln["package_name"],
                            evidence=f"Version {vuln.get('installed_version')} affected",
                            remediation=f"Upgrade to a safe version"
                        )
                        findings.append(finding)
                        
                except json.JSONDecodeError:
                    # Safety might output non-JSON on some versions
                    pass
            
        except Exception as e:
            logger.error("Safety scan failed", error=str(e))
            
        return findings

    def _map_severity(self, severity_str: str) -> VulnerabilitySeverity:
        """Map string severity to enum."""
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "info": VulnerabilitySeverity.INFO
        }
        return severity_map.get(severity_str.lower(), VulnerabilitySeverity.MEDIUM)


class CodeAnalysisScanner(BaseScanner):
    """Scanner for code-level vulnerabilities using bandit and semgrep."""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("code_analysis_scanner", config)
        self.bandit_config_path = self.config.get("bandit_config_path")
        self.semgrep_rules = self.config.get("semgrep_rules", ["python.lang.security"])

    async def scan(self, target: str, **kwargs) -> List[VulnerabilityFinding]:
        """Scan code for vulnerabilities."""
        findings = []
        
        # Scan with bandit
        bandit_findings = await self._scan_with_bandit(target)
        findings.extend(bandit_findings)
        
        # Scan with semgrep
        semgrep_findings = await self._scan_with_semgrep(target)
        findings.extend(semgrep_findings)
        
        return findings

    async def _scan_with_bandit(self, target: str) -> List[VulnerabilityFinding]:
        """Scan code with bandit."""
        findings = []
        
        try:
            cmd = ["bandit", "-r", target, "-f", "json"]
            if self.bandit_config_path:
                cmd.extend(["-c", self.bandit_config_path])
                
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if stdout:
                try:
                    results = json.loads(stdout.decode())
                    
                    for result in results.get("results", []):
                        finding = VulnerabilityFinding(
                            id=self.generate_finding_id("code", result["test_id"]),
                            title=f"Bandit: {result['test_name']}",
                            description=result.get("issue_text", "No description"),
                            severity=self._map_bandit_severity(result.get("issue_severity", "MEDIUM")),
                            category=self._map_bandit_category(result.get("test_id", "")),
                            file_path=result.get("filename"),
                            line_number=result.get("line_number"),
                            evidence=result.get("code", ""),
                            confidence=self._map_bandit_confidence(result.get("issue_confidence", "MEDIUM")),
                            cwe_id=result.get("cwe", {}).get("id")
                        )
                        findings.append(finding)
                        
                except json.JSONDecodeError as e:
                    logger.error("Failed to parse bandit output", error=str(e))
            
        except Exception as e:
            logger.error("Bandit scan failed", error=str(e))
            
        return findings

    async def _scan_with_semgrep(self, target: str) -> List[VulnerabilityFinding]:
        """Scan code with semgrep."""
        findings = []
        
        try:
            for rule in self.semgrep_rules:
                cmd = ["semgrep", "--config", rule, "--json", target]
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if stdout:
                    try:
                        results = json.loads(stdout.decode())
                        
                        for result in results.get("results", []):
                            finding = VulnerabilityFinding(
                                id=self.generate_finding_id("code", result["check_id"]),
                                title=f"Semgrep: {result['check_id']}",
                                description=result.get("message", "No description"),
                                severity=self._map_semgrep_severity(result.get("severity", "WARNING")),
                                category=self._categorize_semgrep_rule(result.get("check_id", "")),
                                file_path=result.get("path"),
                                line_number=result.get("start", {}).get("line"),
                                evidence=result.get("extra", {}).get("lines", "")
                            )
                            findings.append(finding)
                            
                    except json.JSONDecodeError as e:
                        logger.error("Failed to parse semgrep output", error=str(e))
            
        except Exception as e:
            logger.error("Semgrep scan failed", error=str(e))
            
        return findings

    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map bandit severity to enum."""
        severity_map = {
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW
        }
        return severity_map.get(severity, VulnerabilitySeverity.MEDIUM)

    def _map_bandit_confidence(self, confidence: str) -> float:
        """Map bandit confidence to float."""
        confidence_map = {
            "HIGH": 0.9,
            "MEDIUM": 0.6,
            "LOW": 0.3
        }
        return confidence_map.get(confidence, 0.6)

    def _map_bandit_category(self, test_id: str) -> VulnerabilityCategory:
        """Map bandit test ID to vulnerability category."""
        if "inject" in test_id.lower():
            return VulnerabilityCategory.INJECTION
        elif "crypto" in test_id.lower() or "hash" in test_id.lower():
            return VulnerabilityCategory.CRYPTOGRAPHY
        elif "auth" in test_id.lower():
            return VulnerabilityCategory.AUTHENTICATION
        else:
            return VulnerabilityCategory.CONFIGURATION

    def _map_semgrep_severity(self, severity: str) -> VulnerabilitySeverity:
        """Map semgrep severity to enum."""
        severity_map = {
            "ERROR": VulnerabilitySeverity.HIGH,
            "WARNING": VulnerabilitySeverity.MEDIUM,
            "INFO": VulnerabilitySeverity.LOW
        }
        return severity_map.get(severity, VulnerabilitySeverity.MEDIUM)

    def _categorize_semgrep_rule(self, rule_id: str) -> VulnerabilityCategory:
        """Categorize semgrep rule by ID."""
        rule_lower = rule_id.lower()
        
        if "inject" in rule_lower or "sqli" in rule_lower:
            return VulnerabilityCategory.INJECTION
        elif "crypto" in rule_lower or "hash" in rule_lower:
            return VulnerabilityCategory.CRYPTOGRAPHY
        elif "auth" in rule_lower:
            return VulnerabilityCategory.AUTHENTICATION
        elif "input" in rule_lower or "validation" in rule_lower:
            return VulnerabilityCategory.INPUT_VALIDATION
        else:
            return VulnerabilityCategory.CONFIGURATION


class APISecurityScanner(BaseScanner):
    """Scanner for API security vulnerabilities."""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("api_security_scanner", config)
        self.base_url = self.config.get("base_url", "http://localhost:8000")
        self.timeout = self.config.get("timeout", 30)

    async def scan(self, target: str, **kwargs) -> List[VulnerabilityFinding]:
        """Scan API for security vulnerabilities."""
        findings = []
        
        # Authentication bypass tests
        auth_findings = await self._test_authentication_bypass()
        findings.extend(auth_findings)
        
        # Input validation tests
        input_findings = await self._test_input_validation()
        findings.extend(input_findings)
        
        # Rate limiting tests
        rate_findings = await self._test_rate_limiting()
        findings.extend(rate_findings)
        
        # Information disclosure tests
        info_findings = await self._test_information_disclosure()
        findings.extend(info_findings)
        
        return findings

    async def _test_authentication_bypass(self) -> List[VulnerabilityFinding]:
        """Test for authentication bypass vulnerabilities."""
        findings = []
        
        endpoints = [
            "/api/v1/detection/detect",
            "/api/v1/models/list",
            "/api/v1/admin/users"
        ]
        
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            for endpoint in endpoints:
                try:
                    # Test without authentication
                    response = await client.post(f"{self.base_url}{endpoint}")
                    
                    if response.status_code == 200:
                        finding = VulnerabilityFinding(
                            id=self.generate_finding_id("api", f"auth_bypass_{endpoint}"),
                            title=f"Authentication bypass in {endpoint}",
                            description=f"Endpoint {endpoint} accessible without authentication",
                            severity=VulnerabilitySeverity.HIGH,
                            category=VulnerabilityCategory.AUTHENTICATION,
                            affected_component=endpoint,
                            evidence=f"HTTP {response.status_code} returned",
                            remediation="Implement proper authentication checks"
                        )
                        findings.append(finding)
                        
                except Exception as e:
                    logger.debug(f"Auth bypass test failed for {endpoint}", error=str(e))
                    
        return findings

    async def _test_input_validation(self) -> List[VulnerabilityFinding]:
        """Test for input validation vulnerabilities."""
        findings = []
        
        # SQL injection payloads
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "1' UNION SELECT * FROM users --"
        ]
        
        # XSS payloads
        xss_payloads = [
            "<script>alert('xss')</script>",
            "javascript:alert('xss')",
            "<img src=x onerror=alert('xss')>"
        ]
        
        # Command injection payloads
        cmd_payloads = [
            "; ls -la",
            "| whoami",
            "&& cat /etc/passwd"
        ]
        
        test_endpoint = f"{self.base_url}/api/v1/detection/detect"
        
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            # Test each payload type
            for payload_type, payloads in [("sql", sql_payloads), ("xss", xss_payloads), ("cmd", cmd_payloads)]:
                for payload in payloads:
                    try:
                        test_data = {
                            "data": [[1, 2, 3], [4, 5, 6]],
                            "algorithm": payload,  # Inject into algorithm parameter
                            "contamination": 0.1
                        }
                        
                        response = await client.post(test_endpoint, json=test_data)
                        
                        # Check for error messages that might indicate vulnerability
                        if response.status_code >= 500:
                            response_text = response.text.lower()
                            if any(indicator in response_text for indicator in ["error", "exception", "traceback"]):
                                finding = VulnerabilityFinding(
                                    id=self.generate_finding_id("api", f"{payload_type}_injection"),
                                    title=f"Potential {payload_type.upper()} injection vulnerability",
                                    description=f"Server error when processing {payload_type} payload",
                                    severity=VulnerabilitySeverity.HIGH,
                                    category=VulnerabilityCategory.INJECTION,
                                    affected_component=test_endpoint,
                                    evidence=f"Payload: {payload}, Response: {response.status_code}",
                                    remediation="Implement proper input validation and sanitization"
                                )
                                findings.append(finding)
                                
                    except Exception as e:
                        logger.debug(f"Input validation test failed", payload=payload, error=str(e))
                        
        return findings

    async def _test_rate_limiting(self) -> List[VulnerabilityFinding]:
        """Test for rate limiting vulnerabilities."""
        findings = []
        
        test_endpoint = f"{self.base_url}/api/v1/detection/detect"
        
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            try:
                # Send rapid requests
                tasks = []
                for _ in range(50):  # 50 rapid requests
                    task = client.post(test_endpoint, json={
                        "data": [[1, 2, 3]],
                        "algorithm": "iforest",
                        "contamination": 0.1
                    })
                    tasks.append(task)
                
                responses = await asyncio.gather(*tasks, return_exceptions=True)
                
                # Count successful responses
                success_count = sum(1 for r in responses if isinstance(r, httpx.Response) and r.status_code == 200)
                
                if success_count > 30:  # If more than 30 requests succeeded
                    finding = VulnerabilityFinding(
                        id=self.generate_finding_id("api", "no_rate_limiting"),
                        title="Missing rate limiting",
                        description="API does not implement rate limiting",
                        severity=VulnerabilitySeverity.MEDIUM,
                        category=VulnerabilityCategory.DENIAL_OF_SERVICE,
                        affected_component=test_endpoint,
                        evidence=f"{success_count}/50 requests succeeded",
                        remediation="Implement rate limiting to prevent abuse"
                    )
                    findings.append(finding)
                    
            except Exception as e:
                logger.debug("Rate limiting test failed", error=str(e))
                
        return findings

    async def _test_information_disclosure(self) -> List[VulnerabilityFinding]:
        """Test for information disclosure vulnerabilities."""
        findings = []
        
        test_endpoints = [
            "/api/v1/health",
            "/api/v1/metrics",
            "/docs",
            "/openapi.json"
        ]
        
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            for endpoint in test_endpoints:
                try:
                    response = await client.get(f"{self.base_url}{endpoint}")
                    
                    if response.status_code == 200:
                        response_text = response.text.lower()
                        
                        # Check for sensitive information
                        sensitive_patterns = [
                            r'password["\']?\s*[:=]\s*["\']?[^"\s,}]+',
                            r'api[_-]?key["\']?\s*[:=]\s*["\']?[^"\s,}]+',
                            r'secret["\']?\s*[:=]\s*["\']?[^"\s,}]+',
                            r'token["\']?\s*[:=]\s*["\']?[^"\s,}]+',
                            r'/home/[^/\s]+',
                            r'db[_-]?host["\']?\s*[:=]\s*["\']?[^"\s,}]+'
                        ]
                        
                        for pattern in sensitive_patterns:
                            if re.search(pattern, response_text, re.IGNORECASE):
                                finding = VulnerabilityFinding(
                                    id=self.generate_finding_id("api", f"info_disclosure_{endpoint}"),
                                    title=f"Information disclosure in {endpoint}",
                                    description=f"Sensitive information exposed in {endpoint}",
                                    severity=VulnerabilitySeverity.MEDIUM,
                                    category=VulnerabilityCategory.DATA_EXPOSURE,
                                    affected_component=endpoint,
                                    evidence=f"Pattern matched: {pattern}",
                                    remediation="Remove sensitive information from public endpoints"
                                )
                                findings.append(finding)
                                break
                                
                except Exception as e:
                    logger.debug(f"Info disclosure test failed for {endpoint}", error=str(e))
                    
        return findings


class VulnerabilityScanner:
    """Main vulnerability scanner orchestrator."""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize vulnerability scanner.
        
        Args:
            config: Scanner configuration dictionary
        """
        self.config = config or {}
        
        # Initialize scanners
        self.scanners = {
            "dependency": DependencyScanner(self.config.get("dependency", {})),
            "code_analysis": CodeAnalysisScanner(self.config.get("code_analysis", {})),
            "api_security": APISecurityScanner(self.config.get("api_security", {}))
        }
        
        # Filter enabled scanners
        self.enabled_scanners = {
            name: scanner for name, scanner in self.scanners.items() 
            if scanner.enabled
        }
        
        logger.info("VulnerabilityScanner initialized",
                   enabled_scanners=list(self.enabled_scanners.keys()))

    async def scan_all(
        self,
        target: str,
        scan_types: Optional[List[str]] = None
    ) -> ScanResult:
        """Run comprehensive vulnerability scan.
        
        Args:
            target: Target to scan (path, URL, etc.)
            scan_types: Specific scan types to run
            
        Returns:
            Comprehensive scan result
        """
        scan_id = self._generate_scan_id()
        start_time = datetime.utcnow()
        
        logger.info("Starting comprehensive vulnerability scan",
                   scan_id=scan_id,
                   target=target,
                   scan_types=scan_types)
        
        all_findings = []
        total_checks = 0
        passed_checks = 0
        failed_checks = 0
        
        # Determine which scanners to run
        scanners_to_run = self.enabled_scanners
        if scan_types:
            scanners_to_run = {
                name: scanner for name, scanner in self.enabled_scanners.items()
                if name in scan_types
            }
        
        # Run each scanner
        for scanner_name, scanner in scanners_to_run.items():
            try:
                logger.info(f"Running {scanner_name} scanner", target=target)
                
                scanner_findings = await scanner.scan(target)
                all_findings.extend(scanner_findings)
                
                # Update metrics
                total_checks += 1
                if scanner_findings:
                    failed_checks += 1
                else:
                    passed_checks += 1
                
                # Record metrics
                metrics_collector.record_metric(
                    f"security.scanner.{scanner_name}.findings",
                    len(scanner_findings),
                    {"scan_id": scan_id}
                )
                
                logger.info(f"Completed {scanner_name} scanner",
                           findings_count=len(scanner_findings))
                
            except Exception as e:
                logger.error(f"Scanner {scanner_name} failed",
                           error=str(e), scan_id=scan_id)
                failed_checks += 1
        
        end_time = datetime.utcnow()
        scan_duration = (end_time - start_time).total_seconds()
        
        # Create scan result
        result = ScanResult(
            scan_id=scan_id,
            scan_type="comprehensive",
            start_time=start_time,
            end_time=end_time,
            target=target,
            findings=all_findings,
            scan_duration=scan_duration,
            total_checks=total_checks,
            passed_checks=passed_checks,
            failed_checks=failed_checks,
            metadata={
                "scanners_used": list(scanners_to_run.keys()),
                "target_type": self._detect_target_type(target)
            }
        )
        
        # Log summary
        logger.info("Vulnerability scan completed",
                   scan_id=scan_id,
                   total_findings=len(all_findings),
                   critical_findings=len(result.critical_findings),
                   high_findings=len(result.high_findings),
                   scan_duration=scan_duration)
        
        # Record overall metrics
        metrics_collector.record_metric(
            "security.scan.duration_seconds",
            scan_duration,
            {"scan_id": scan_id}
        )
        
        metrics_collector.record_metric(
            "security.scan.total_findings",
            len(all_findings),
            {"scan_id": scan_id}
        )
        
        return result

    async def scan_dependencies(self, requirements_file: str) -> ScanResult:
        """Scan dependencies for vulnerabilities.
        
        Args:
            requirements_file: Path to requirements file
            
        Returns:
            Dependency scan result
        """
        return await self._run_single_scan("dependency", requirements_file)

    async def scan_code(self, code_path: str) -> ScanResult:
        """Scan code for vulnerabilities.
        
        Args:
            code_path: Path to code directory
            
        Returns:
            Code analysis scan result
        """
        return await self._run_single_scan("code_analysis", code_path)

    async def scan_api(self, base_url: str) -> ScanResult:
        """Scan API for security vulnerabilities.
        
        Args:
            base_url: Base URL of API
            
        Returns:
            API security scan result
        """
        return await self._run_single_scan("api_security", base_url)

    async def _run_single_scan(self, scanner_name: str, target: str) -> ScanResult:
        """Run a single scanner."""
        scan_id = self._generate_scan_id()
        start_time = datetime.utcnow()
        
        if scanner_name not in self.enabled_scanners:
            raise ValueError(f"Scanner {scanner_name} not enabled or not found")
        
        scanner = self.enabled_scanners[scanner_name]
        
        try:
            findings = await scanner.scan(target)
            
            end_time = datetime.utcnow()
            scan_duration = (end_time - start_time).total_seconds()
            
            return ScanResult(
                scan_id=scan_id,
                scan_type=scanner_name,
                start_time=start_time,
                end_time=end_time,
                target=target,
                findings=findings,
                scan_duration=scan_duration,
                total_checks=1,
                passed_checks=0 if findings else 1,
                failed_checks=1 if findings else 0,
                metadata={"scanner": scanner_name}
            )
            
        except Exception as e:
            end_time = datetime.utcnow()
            scan_duration = (end_time - start_time).total_seconds()
            
            logger.error(f"Single scan failed", scanner=scanner_name, error=str(e))
            
            return ScanResult(
                scan_id=scan_id,
                scan_type=scanner_name,
                start_time=start_time,
                end_time=end_time,
                target=target,
                findings=[],
                scan_duration=scan_duration,
                total_checks=1,
                passed_checks=0,
                failed_checks=1,
                metadata={"scanner": scanner_name, "error": str(e)}
            )

    def generate_report(self, scan_result: ScanResult) -> Dict[str, Any]:
        """Generate comprehensive vulnerability report.
        
        Args:
            scan_result: Scan result to report on
            
        Returns:
            Comprehensive report dictionary
        """
        # Group findings by severity
        findings_by_severity = {}
        for severity in VulnerabilitySeverity:
            findings_by_severity[severity.value] = [
                f for f in scan_result.findings if f.severity == severity
            ]
        
        # Group findings by category
        findings_by_category = {}
        for category in VulnerabilityCategory:
            findings_by_category[category.value] = [
                f for f in scan_result.findings if f.category == category
            ]
        
        # Calculate risk score
        risk_score = self._calculate_risk_score(scan_result.findings)
        
        report = {
            "scan_info": {
                "scan_id": scan_result.scan_id,
                "scan_type": scan_result.scan_type,
                "target": scan_result.target,
                "start_time": scan_result.start_time.isoformat(),
                "end_time": scan_result.end_time.isoformat(),
                "duration_seconds": scan_result.scan_duration
            },
            "summary": {
                "total_findings": len(scan_result.findings),
                "critical_findings": len(findings_by_severity["critical"]),
                "high_findings": len(findings_by_severity["high"]),
                "medium_findings": len(findings_by_severity["medium"]),
                "low_findings": len(findings_by_severity["low"]),
                "info_findings": len(findings_by_severity["info"]),
                "risk_score": risk_score,
                "success_rate": scan_result.success_rate
            },
            "findings_by_severity": {
                severity: [self._finding_to_dict(f) for f in findings]
                for severity, findings in findings_by_severity.items()
                if findings
            },
            "findings_by_category": {
                category: len(findings)
                for category, findings in findings_by_category.items()
                if findings
            },
            "recommendations": self._generate_recommendations(scan_result.findings),
            "metadata": scan_result.metadata
        }
        
        return report

    def _generate_scan_id(self) -> str:
        """Generate unique scan ID."""
        timestamp = str(int(time.time()))
        return f"scan_{timestamp}_{hashlib.md5(timestamp.encode()).hexdigest()[:8]}"

    def _detect_target_type(self, target: str) -> str:
        """Detect target type from target string."""
        if target.startswith(("http://", "https://")):
            return "url"
        elif Path(target).is_file():
            return "file"
        elif Path(target).is_dir():
            return "directory"
        else:
            return "unknown"

    def _calculate_risk_score(self, findings: List[VulnerabilityFinding]) -> float:
        """Calculate overall risk score (0-100)."""
        if not findings:
            return 0.0
        
        # Weight findings by severity
        severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10,
            VulnerabilitySeverity.HIGH: 7,
            VulnerabilitySeverity.MEDIUM: 4,
            VulnerabilitySeverity.LOW: 2,
            VulnerabilitySeverity.INFO: 1
        }
        
        total_score = sum(
            severity_weights.get(finding.severity, 1) * finding.confidence
            for finding in findings
        )
        
        # Normalize to 0-100 scale
        max_possible_score = len(findings) * 10  # All critical with full confidence
        if max_possible_score == 0:
            return 0.0
            
        return min(100.0, (total_score / max_possible_score) * 100)

    def _finding_to_dict(self, finding: VulnerabilityFinding) -> Dict[str, Any]:
        """Convert finding to dictionary."""
        return {
            "id": finding.id,
            "title": finding.title,
            "description": finding.description,
            "severity": finding.severity.value,
            "category": finding.category.value,
            "cwe_id": finding.cwe_id,
            "cvss_score": finding.cvss_score,
            "affected_component": finding.affected_component,
            "file_path": finding.file_path,
            "line_number": finding.line_number,
            "evidence": finding.evidence,
            "remediation": finding.remediation,
            "references": finding.references,
            "timestamp": finding.timestamp.isoformat(),
            "confidence": finding.confidence
        }

    def _generate_recommendations(self, findings: List[VulnerabilityFinding]) -> List[str]:
        """Generate remediation recommendations."""
        recommendations = []
        
        # Group by category for targeted recommendations
        categories = set(f.category for f in findings)
        
        if VulnerabilityCategory.DEPENDENCIES in categories:
            recommendations.append(
                "Update vulnerable dependencies to their latest secure versions"
            )
            
        if VulnerabilityCategory.INJECTION in categories:
            recommendations.append(
                "Implement input validation and parameterized queries to prevent injection attacks"
            )
            
        if VulnerabilityCategory.AUTHENTICATION in categories:
            recommendations.append(
                "Strengthen authentication mechanisms and implement proper access controls"
            )
            
        if VulnerabilityCategory.CRYPTOGRAPHY in categories:
            recommendations.append(
                "Use secure cryptographic algorithms and proper key management"
            )
            
        if VulnerabilityCategory.CONFIGURATION in categories:
            recommendations.append(
                "Review and harden system configuration settings"
            )
        
        # Add critical/high severity specific recommendations
        critical_high_findings = [
            f for f in findings 
            if f.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]
        ]
        
        if critical_high_findings:
            recommendations.insert(0,
                f"Prioritize fixing {len(critical_high_findings)} critical/high severity vulnerabilities"
            )
        
        return recommendations


# Global scanner instance
_vulnerability_scanner: Optional[VulnerabilityScanner] = None


def get_vulnerability_scanner(config: Optional[Dict[str, Any]] = None) -> VulnerabilityScanner:
    """Get the global vulnerability scanner instance."""
    global _vulnerability_scanner
    
    if _vulnerability_scanner is None or config is not None:
        _vulnerability_scanner = VulnerabilityScanner(config)
    
    return _vulnerability_scanner


def initialize_vulnerability_scanner(config: Optional[Dict[str, Any]] = None) -> VulnerabilityScanner:
    """Initialize the global vulnerability scanner."""
    global _vulnerability_scanner
    _vulnerability_scanner = VulnerabilityScanner(config)
    return _vulnerability_scanner