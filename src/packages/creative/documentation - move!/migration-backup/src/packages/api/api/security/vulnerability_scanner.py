"""
Vulnerability scanning and security assessment for Pynomaly API.

This module provides:
- Automated vulnerability scanning
- Dependency vulnerability checks
- Configuration security assessment
- Code security analysis
- Security compliance reporting
"""

import hashlib
import json
import logging
import os
import re
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from typing import Any

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(str, Enum):
    """Vulnerability severity levels."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class VulnerabilityType(str, Enum):
    """Types of vulnerabilities."""

    DEPENDENCY = "dependency"
    CONFIGURATION = "configuration"
    CODE = "code"
    INFRASTRUCTURE = "infrastructure"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INPUT_VALIDATION = "input_validation"
    ENCRYPTION = "encryption"
    SESSION_MANAGEMENT = "session_management"


@dataclass
class Vulnerability:
    """Vulnerability data structure."""

    vuln_id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    vuln_type: VulnerabilityType
    affected_component: str
    cve_id: str | None = None
    cvss_score: float | None = None
    remediation: str = ""
    references: list[str] = None
    discovered_at: datetime = None

    def __post_init__(self):
        if self.references is None:
            self.references = []
        if self.discovered_at is None:
            self.discovered_at = datetime.utcnow()


class VulnerabilityScanner:
    """Comprehensive vulnerability scanner."""

    def __init__(self):
        self.vulnerabilities = []
        self.scan_history = []
        self.configuration_checks = self._initialize_config_checks()
        self.code_patterns = self._initialize_code_patterns()
        self.dependency_cache = {}

    def _initialize_config_checks(self) -> list[dict[str, Any]]:
        """Initialize configuration security checks."""
        return [
            {
                "name": "debug_mode_enabled",
                "description": "Debug mode should be disabled in production",
                "check": lambda config: config.get("DEBUG", False),
                "severity": VulnerabilitySeverity.HIGH,
                "remediation": "Set DEBUG=False in production configuration",
            },
            {
                "name": "weak_secret_key",
                "description": "Secret key is weak or default",
                "check": lambda config: len(config.get("SECRET_KEY", "")) < 32,
                "severity": VulnerabilitySeverity.CRITICAL,
                "remediation": "Use a strong, randomly generated secret key",
            },
            {
                "name": "missing_security_headers",
                "description": "Security headers not configured",
                "check": lambda config: not config.get("SECURITY_HEADERS", {}),
                "severity": VulnerabilitySeverity.MEDIUM,
                "remediation": "Configure security headers (HSTS, CSP, etc.)",
            },
            {
                "name": "insecure_ssl_config",
                "description": "SSL/TLS configuration is insecure",
                "check": lambda config: config.get("SSL_VERIFY", True) == False,
                "severity": VulnerabilitySeverity.HIGH,
                "remediation": "Enable SSL certificate verification",
            },
            {
                "name": "weak_password_policy",
                "description": "Password policy is too weak",
                "check": lambda config: config.get("MIN_PASSWORD_LENGTH", 0) < 8,
                "severity": VulnerabilitySeverity.MEDIUM,
                "remediation": "Enforce minimum password length of 8 characters",
            },
        ]

    def _initialize_code_patterns(self) -> list[dict[str, Any]]:
        """Initialize code security patterns."""
        return [
            {
                "name": "hardcoded_secrets",
                "pattern": r'(password|secret|key|token)\s*=\s*["\'][^"\']{8,}["\']',
                "description": "Hardcoded secrets detected",
                "severity": VulnerabilitySeverity.CRITICAL,
                "remediation": "Move secrets to environment variables or secure vaults",
            },
            {
                "name": "sql_injection_risk",
                "pattern": r'(execute|query)\s*\(\s*["\'].*%s.*["\']',
                "description": "Potential SQL injection vulnerability",
                "severity": VulnerabilitySeverity.HIGH,
                "remediation": "Use parameterized queries or ORM",
            },
            {
                "name": "command_injection_risk",
                "pattern": r"(os\.system|subprocess\.call|exec|eval)\s*\([^)]*user",
                "description": "Potential command injection vulnerability",
                "severity": VulnerabilitySeverity.HIGH,
                "remediation": "Sanitize user input and use safe APIs",
            },
            {
                "name": "path_traversal_risk",
                "pattern": r"(open|read|write)\s*\([^)]*\.\.[/\\]",
                "description": "Potential path traversal vulnerability",
                "severity": VulnerabilitySeverity.MEDIUM,
                "remediation": "Validate and sanitize file paths",
            },
            {
                "name": "insecure_random",
                "pattern": r"random\.(random|randint|choice)",
                "description": "Use of insecure random number generator",
                "severity": VulnerabilitySeverity.MEDIUM,
                "remediation": "Use secrets module for cryptographic purposes",
            },
            {
                "name": "debug_prints",
                "pattern": r"print\s*\([^)]*password|token|secret[^)]*\)",
                "description": "Potential information leakage through debug prints",
                "severity": VulnerabilitySeverity.LOW,
                "remediation": "Remove debug prints containing sensitive data",
            },
        ]

    def scan_all(
        self,
        config: dict[str, Any],
        code_paths: list[str],
        requirements_file: str = "requirements.txt",
    ) -> dict[str, Any]:
        """Perform comprehensive security scan."""
        scan_id = f"scan_{int(datetime.utcnow().timestamp())}"
        scan_start = datetime.utcnow()

        results = {
            "scan_id": scan_id,
            "start_time": scan_start.isoformat(),
            "vulnerabilities": [],
            "summary": {},
            "recommendations": [],
        }

        try:
            # Configuration scan
            config_vulns = self.scan_configuration(config)
            results["vulnerabilities"].extend(config_vulns)

            # Code scan
            for code_path in code_paths:
                code_vulns = self.scan_code(code_path)
                results["vulnerabilities"].extend(code_vulns)

            # Dependency scan
            if os.path.exists(requirements_file):
                dep_vulns = self.scan_dependencies(requirements_file)
                results["vulnerabilities"].extend(dep_vulns)

            # Infrastructure scan
            infra_vulns = self.scan_infrastructure()
            results["vulnerabilities"].extend(infra_vulns)

            # Generate summary
            results["summary"] = self._generate_summary(results["vulnerabilities"])
            results["recommendations"] = self._generate_recommendations(
                results["vulnerabilities"]
            )

            scan_end = datetime.utcnow()
            results["end_time"] = scan_end.isoformat()
            results["duration"] = (scan_end - scan_start).total_seconds()

            # Store scan history
            self.scan_history.append(results)

            logger.info(
                f"Security scan {scan_id} completed with {len(results['vulnerabilities'])} vulnerabilities found"
            )

        except Exception as e:
            logger.error(f"Security scan failed: {e}")
            results["error"] = str(e)

        return results

    def scan_configuration(self, config: dict[str, Any]) -> list[Vulnerability]:
        """Scan configuration for security issues."""
        vulnerabilities = []

        for check in self.configuration_checks:
            try:
                if check["check"](config):
                    vuln = Vulnerability(
                        vuln_id=f"config_{check['name']}_{int(datetime.utcnow().timestamp())}",
                        title=check["name"].replace("_", " ").title(),
                        description=check["description"],
                        severity=check["severity"],
                        vuln_type=VulnerabilityType.CONFIGURATION,
                        affected_component="configuration",
                        remediation=check["remediation"],
                    )
                    vulnerabilities.append(vuln)
            except Exception as e:
                logger.warning(f"Configuration check {check['name']} failed: {e}")

        return vulnerabilities

    def scan_code(self, code_path: str) -> list[Vulnerability]:
        """Scan code files for security issues."""
        vulnerabilities = []

        if not os.path.exists(code_path):
            logger.warning(f"Code path does not exist: {code_path}")
            return vulnerabilities

        # Scan Python files
        for root, dirs, files in os.walk(code_path):
            for file in files:
                if file.endswith(".py"):
                    file_path = os.path.join(root, file)
                    file_vulns = self._scan_file(file_path)
                    vulnerabilities.extend(file_vulns)

        return vulnerabilities

    def _scan_file(self, file_path: str) -> list[Vulnerability]:
        """Scan individual file for security issues."""
        vulnerabilities = []

        try:
            with open(file_path, encoding="utf-8") as f:
                content = f.read()

            for pattern_check in self.code_patterns:
                matches = re.finditer(pattern_check["pattern"], content, re.IGNORECASE)

                for match in matches:
                    line_num = content[: match.start()].count("\\n") + 1

                    vuln = Vulnerability(
                        vuln_id=f"code_{pattern_check['name']}_{hashlib.md5(f'{file_path}:{line_num}'.encode()).hexdigest()[:8]}",
                        title=pattern_check["name"].replace("_", " ").title(),
                        description=f"{pattern_check['description']} in {file_path}:{line_num}",
                        severity=pattern_check["severity"],
                        vuln_type=VulnerabilityType.CODE,
                        affected_component=file_path,
                        remediation=pattern_check["remediation"],
                    )
                    vulnerabilities.append(vuln)

        except Exception as e:
            logger.warning(f"Failed to scan file {file_path}: {e}")

        return vulnerabilities

    def scan_dependencies(self, requirements_file: str) -> list[Vulnerability]:
        """Scan dependencies for known vulnerabilities."""
        vulnerabilities = []

        try:
            # Parse requirements file
            dependencies = self._parse_requirements(requirements_file)

            # Check each dependency
            for dep_name, version in dependencies.items():
                dep_vulns = self._check_dependency_vulnerabilities(dep_name, version)
                vulnerabilities.extend(dep_vulns)

        except Exception as e:
            logger.error(f"Dependency scan failed: {e}")

        return vulnerabilities

    def _parse_requirements(self, requirements_file: str) -> dict[str, str]:
        """Parse requirements.txt file."""
        dependencies = {}

        with open(requirements_file) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    # Simple parsing - could be enhanced
                    if "==" in line:
                        name, version = line.split("==", 1)
                        dependencies[name.strip()] = version.strip()
                    elif ">=" in line:
                        name, version = line.split(">=", 1)
                        dependencies[name.strip()] = version.strip()
                    else:
                        dependencies[line] = "unknown"

        return dependencies

    def _check_dependency_vulnerabilities(
        self, dep_name: str, version: str
    ) -> list[Vulnerability]:
        """Check dependency for known vulnerabilities."""
        vulnerabilities = []

        # Use cache to avoid repeated API calls
        cache_key = f"{dep_name}:{version}"
        if cache_key in self.dependency_cache:
            return self.dependency_cache[cache_key]

        try:
            # Check PyUp.io safety database (placeholder)
            # In production, would use actual vulnerability databases
            known_vulns = self._get_known_vulnerabilities(dep_name, version)

            for vuln_data in known_vulns:
                vuln = Vulnerability(
                    vuln_id=vuln_data.get(
                        "id", f"dep_{dep_name}_{int(datetime.utcnow().timestamp())}"
                    ),
                    title=f"Vulnerable dependency: {dep_name}",
                    description=vuln_data.get(
                        "description", f"Known vulnerability in {dep_name} {version}"
                    ),
                    severity=VulnerabilitySeverity(vuln_data.get("severity", "medium")),
                    vuln_type=VulnerabilityType.DEPENDENCY,
                    affected_component=f"{dep_name}=={version}",
                    cve_id=vuln_data.get("cve"),
                    cvss_score=vuln_data.get("cvss_score"),
                    remediation=f"Update {dep_name} to version {vuln_data.get('fixed_version', 'latest')}",
                    references=vuln_data.get("references", []),
                )
                vulnerabilities.append(vuln)

            self.dependency_cache[cache_key] = vulnerabilities

        except Exception as e:
            logger.warning(f"Failed to check vulnerabilities for {dep_name}: {e}")

        return vulnerabilities

    def _get_known_vulnerabilities(
        self, dep_name: str, version: str
    ) -> list[dict[str, Any]]:
        """Get known vulnerabilities for dependency (mock implementation)."""
        # This is a mock implementation. In production, would query:
        # - PyUp.io Safety Database
        # - National Vulnerability Database (NVD)
        # - GitHub Advisory Database
        # - Snyk vulnerability database

        # Mock vulnerabilities for demonstration
        mock_vulns = {
            "requests": [
                {
                    "id": "CVE-2023-32681",
                    "description": "Requests library has a potential security vulnerability",
                    "severity": "medium",
                    "cve": "CVE-2023-32681",
                    "cvss_score": 6.1,
                    "fixed_version": "2.31.0",
                    "references": ["https://nvd.nist.gov/vuln/detail/CVE-2023-32681"],
                }
            ],
            "flask": [
                {
                    "id": "FLASK-2023-001",
                    "description": "Flask may be vulnerable to template injection",
                    "severity": "high",
                    "fixed_version": "2.3.0",
                    "references": ["https://flask.palletsprojects.com/security/"],
                }
            ],
        }

        return mock_vulns.get(dep_name.lower(), [])

    def scan_infrastructure(self) -> list[Vulnerability]:
        """Scan infrastructure configuration."""
        vulnerabilities = []

        # Check SSL/TLS configuration
        ssl_vulns = self._check_ssl_configuration()
        vulnerabilities.extend(ssl_vulns)

        # Check network configuration
        network_vulns = self._check_network_configuration()
        vulnerabilities.extend(network_vulns)

        # Check file permissions
        perm_vulns = self._check_file_permissions()
        vulnerabilities.extend(perm_vulns)

        return vulnerabilities

    def _check_ssl_configuration(self) -> list[Vulnerability]:
        """Check SSL/TLS configuration."""
        vulnerabilities = []

        # Mock SSL checks
        # In production, would check:
        # - Certificate validity
        # - Cipher suites
        # - Protocol versions
        # - HSTS configuration

        return vulnerabilities

    def _check_network_configuration(self) -> list[Vulnerability]:
        """Check network security configuration."""
        vulnerabilities = []

        # Check for open ports (mock)
        # In production, would scan actual network configuration

        return vulnerabilities

    def _check_file_permissions(self) -> list[Vulnerability]:
        """Check file and directory permissions."""
        vulnerabilities = []

        sensitive_files = [".env", "config.py", "settings.py", "database.conf"]

        for file_name in sensitive_files:
            if os.path.exists(file_name):
                stat = os.stat(file_name)
                permissions = oct(stat.st_mode)[-3:]

                # Check if file is world-readable
                if permissions[2] != "0":
                    vuln = Vulnerability(
                        vuln_id=f"perm_{file_name}_{int(datetime.utcnow().timestamp())}",
                        title="Insecure File Permissions",
                        description=f"Sensitive file {file_name} is world-readable (permissions: {permissions})",
                        severity=VulnerabilitySeverity.MEDIUM,
                        vuln_type=VulnerabilityType.CONFIGURATION,
                        affected_component=file_name,
                        remediation=f"Change permissions of {file_name} to 600 or 640",
                    )
                    vulnerabilities.append(vuln)

        return vulnerabilities

    def _generate_summary(self, vulnerabilities: list[Vulnerability]) -> dict[str, Any]:
        """Generate vulnerability summary."""
        summary = {
            "total_vulnerabilities": len(vulnerabilities),
            "by_severity": {"critical": 0, "high": 0, "medium": 0, "low": 0},
            "by_type": {},
            "risk_score": 0.0,
        }

        risk_scores = {
            VulnerabilitySeverity.CRITICAL: 10.0,
            VulnerabilitySeverity.HIGH: 7.0,
            VulnerabilitySeverity.MEDIUM: 4.0,
            VulnerabilitySeverity.LOW: 1.0,
        }

        total_risk = 0.0

        for vuln in vulnerabilities:
            summary["by_severity"][vuln.severity] += 1

            vuln_type = vuln.vuln_type
            if vuln_type not in summary["by_type"]:
                summary["by_type"][vuln_type] = 0
            summary["by_type"][vuln_type] += 1

            total_risk += risk_scores.get(vuln.severity, 0.0)

        if vulnerabilities:
            summary["risk_score"] = total_risk / len(vulnerabilities)

        return summary

    def _generate_recommendations(
        self, vulnerabilities: list[Vulnerability]
    ) -> list[str]:
        """Generate security recommendations."""
        recommendations = []

        # Count vulnerabilities by type
        type_counts = {}
        for vuln in vulnerabilities:
            type_counts[vuln.vuln_type] = type_counts.get(vuln.vuln_type, 0) + 1

        # Generate recommendations based on findings
        if type_counts.get(VulnerabilityType.DEPENDENCY, 0) > 0:
            recommendations.append("Update dependencies to latest secure versions")
            recommendations.append(
                "Implement automated dependency vulnerability scanning"
            )

        if type_counts.get(VulnerabilityType.CONFIGURATION, 0) > 0:
            recommendations.append("Review and harden configuration settings")
            recommendations.append("Implement configuration management best practices")

        if type_counts.get(VulnerabilityType.CODE, 0) > 0:
            recommendations.append("Implement secure coding practices")
            recommendations.append("Add static code analysis to CI/CD pipeline")
            recommendations.append("Provide security training for developers")

        # Critical vulnerabilities
        critical_vulns = [
            v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL
        ]
        if critical_vulns:
            recommendations.insert(
                0,
                f"URGENT: Address {len(critical_vulns)} critical vulnerabilities immediately",
            )

        return recommendations

    def get_vulnerability_trends(self, days: int = 30) -> dict[str, Any]:
        """Get vulnerability trends over time."""
        cutoff_date = datetime.utcnow() - timedelta(days=days)

        recent_scans = [
            scan
            for scan in self.scan_history
            if datetime.fromisoformat(scan["start_time"]) > cutoff_date
        ]

        trends = {
            "scan_count": len(recent_scans),
            "vulnerability_trend": [],
            "severity_trends": {"critical": [], "high": [], "medium": [], "low": []},
            "risk_score_trend": [],
        }

        for scan in recent_scans:
            trends["vulnerability_trend"].append(
                {
                    "date": scan["start_time"],
                    "count": scan["summary"]["total_vulnerabilities"],
                }
            )

            for severity in ["critical", "high", "medium", "low"]:
                trends["severity_trends"][severity].append(
                    {
                        "date": scan["start_time"],
                        "count": scan["summary"]["by_severity"].get(severity, 0),
                    }
                )

            trends["risk_score_trend"].append(
                {"date": scan["start_time"], "score": scan["summary"]["risk_score"]}
            )

        return trends

    def export_report(self, scan_id: str, format: str = "json") -> str:
        """Export vulnerability report."""
        scan_data = None
        for scan in self.scan_history:
            if scan["scan_id"] == scan_id:
                scan_data = scan
                break

        if not scan_data:
            raise ValueError(f"Scan {scan_id} not found")

        if format == "json":
            return json.dumps(scan_data, indent=2, default=str)
        elif format == "csv":
            return self._export_csv(scan_data)
        else:
            raise ValueError(f"Unsupported format: {format}")

    def _export_csv(self, scan_data: dict[str, Any]) -> str:
        """Export scan results as CSV."""
        import csv
        import io

        output = io.StringIO()
        writer = csv.writer(output)

        # Write header
        writer.writerow(
            [
                "Vulnerability ID",
                "Title",
                "Severity",
                "Type",
                "Component",
                "CVE",
                "CVSS Score",
                "Description",
                "Remediation",
            ]
        )

        # Write vulnerabilities
        for vuln in scan_data["vulnerabilities"]:
            writer.writerow(
                [
                    vuln.vuln_id,
                    vuln.title,
                    vuln.severity,
                    vuln.vuln_type,
                    vuln.affected_component,
                    vuln.cve_id or "",
                    vuln.cvss_score or "",
                    vuln.description,
                    vuln.remediation,
                ]
            )

        return output.getvalue()


def create_scanner_config() -> dict[str, Any]:
    """Create default scanner configuration."""
    return {
        "scan_schedule": "daily",
        "notification_webhooks": [],
        "severity_thresholds": {
            "critical": 0,  # Alert on any critical vulnerabilities
            "high": 5,  # Alert if more than 5 high vulnerabilities
            "medium": 20,  # Alert if more than 20 medium vulnerabilities
        },
        "scan_paths": ["src/", "app/", "lib/"],
        "exclude_patterns": ["*.pyc", "__pycache__", ".git", "node_modules", "venv"],
    }
