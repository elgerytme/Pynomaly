"""Core service implementation for {{package_title}}."""

import asyncio
from typing import Any, Dict, List, Optional
import structlog
from enterprise_core import (
    BaseService,
    Container,
    DomainEvent,
    HealthCheck,
    Metrics,
)
from .config import {{package_module|title}}Config


logger = structlog.get_logger(__name__)


class {{package_module|title}}Service(BaseService):
    """{{package_title}} service implementation."""

    def __init__(
        self,
        config: {{package_module|title}}Config,
        container: Optional[Container] = None,
    ) -> None:
        super().__init__(config, container)
        self._config = config
        self._is_running = False

        # Initialize dependencies
        self._metrics = self._container.get(Metrics) if container else None
        self._health_check = self._container.get(HealthCheck) if container else None

    async def start(self) -> None:
        """Start the service."""
        logger.info("Starting {{package_name}} service", version=self._config.service_version)

        # Initialize service components
        await self._initialize_components()

        self._is_running = True
        logger.info("{{package_name}} service started successfully")

    async def stop(self) -> None:
        """Stop the service."""
        logger.info("Stopping {{package_name}} service")

        self._is_running = False

        # Cleanup components
        await self._cleanup_components()

        logger.info("{{package_name}} service stopped")

    async def process_request(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Process a request with the provided data.

        Args:
            data: Request data to process

        Returns:
            Processed result

        Raises:
            ValueError: If data is invalid
            RuntimeError: If service is not running
        """
        if not self._is_running:
            raise RuntimeError("Service is not running")

        # Record metrics
        if self._metrics:
            self._metrics.counter("{{package_module}}.requests.total")

        try:
            # Validate input
            self._validate_request_data(data)

            # Process the request
            result = await self._process_data(data)

            # Emit domain event
            event = DomainEvent(
                name="{{package_module}}.data_processed",
                data={"input": data, "output": result},
                aggregate_id=data.get("id", "unknown")
            )
            await self._emit_event(event)

            # Record success metrics
            if self._metrics:
                self._metrics.counter("{{package_module}}.requests.success")

            return result

        except Exception as e:
            # Record error metrics
            if self._metrics:
                self._metrics.counter("{{package_module}}.requests.error")

            logger.error("Failed to process request", error=str(e), data=data)
            raise

    async def health_check(self) -> Dict[str, Any]:
        """Check service health status."""
        status = {
            "service": "{{package_name}}",
            "status": "healthy" if self._is_running else "unhealthy",
            "version": self._config.service_version,
            "components": {}
        }

        if self._health_check:
            component_health = await self._health_check.check_all()
            status["components"] = component_health

            # Overall status based on components
            if any(h["status"] != "healthy" for h in component_health.values()):
                status["status"] = "degraded"

        return status

    async def get_metrics(self) -> Dict[str, Any]:
        """Get service metrics."""
        if not self._metrics:
            return {}

        return {
            "service": "{{package_name}}",
            "metrics": self._metrics.get_all(),
        }

    def _validate_request_data(self, data: Dict[str, Any]) -> None:
        """Validate request data format."""
        if not isinstance(data, dict):
            raise ValueError("Request data must be a dictionary")

        # Add specific validation logic here
        required_fields = ["id"]  # Example required fields
        for field in required_fields:
            if field not in data:
                raise ValueError(f"Missing required field: {field}")

    async def _process_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Core data processing logic.

        Override this method to implement specific business logic.
        """
        # Example processing - replace with actual implementation
        processed_data = {
            "id": data["id"],
            "processed_at": self._get_current_timestamp(),
            "result": f"Processed {data.get('type', 'unknown')} data",
            "metadata": {
                "service": "{{package_name}}",
                "version": self._config.service_version,
            }
        }

        # Simulate some processing time
        await asyncio.sleep(0.1)

        return processed_data

    async def _initialize_components(self) -> None:
        """Initialize service components."""
        # Initialize database connections, caches, etc.
        pass

    async def _cleanup_components(self) -> None:
        """Cleanup service components."""
        # Close database connections, caches, etc.
        pass
