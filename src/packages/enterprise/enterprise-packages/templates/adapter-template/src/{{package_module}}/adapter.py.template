"""Core adapter implementation for {{package_title}}."""

import asyncio
from typing import Any, Dict, List, Optional, Union
import httpx
import structlog
from tenacity import retry, stop_after_attempt, wait_exponential
from enterprise_core import ServiceAdapter, CircuitBreaker, RateLimiter
from .config import {{package_module|title}}Config
from .client import {{package_module|title}}Client


logger = structlog.get_logger(__name__)


class {{package_module|title}}Adapter(ServiceAdapter):
    """{{package_title}} implementation."""

    def __init__(self, config: {{package_module|title}}Config) -> None:
        super().__init__(config)
        self._config = config
        self._client: Optional[{{package_module|title}}Client] = None
        self._circuit_breaker: Optional[CircuitBreaker] = None
        self._rate_limiter: Optional[RateLimiter] = None

    async def connect(self) -> None:
        """Establish connection to {{package_name}} service."""
        logger.info("Connecting to {{package_name}} service", base_url=self._config.base_url)

        # Initialize HTTP client
        self._client = {{package_module|title}}Client(self._config)
        await self._client.connect()

        # Initialize circuit breaker
        if self._config.circuit_breaker_enabled:
            self._circuit_breaker = CircuitBreaker(
                failure_threshold=self._config.failure_threshold,
                recovery_timeout=self._config.recovery_timeout,
            )

        # Initialize rate limiter
        if self._config.rate_limit_enabled:
            self._rate_limiter = RateLimiter(
                requests_per_minute=self._config.requests_per_minute
            )

        self._is_connected = True
        logger.info("Connected to {{package_name}} service successfully")

    async def disconnect(self) -> None:
        """Disconnect from {{package_name}} service."""
        logger.info("Disconnecting from {{package_name}} service")

        if self._client:
            await self._client.disconnect()
            self._client = None

        self._is_connected = False
        logger.info("Disconnected from {{package_name}} service")

    async def health_check(self) -> Dict[str, Any]:
        """Check adapter health and connectivity."""
        if not self._is_connected or not self._client:
            return {
                "status": "unhealthy",
                "reason": "Not connected to {{package_name}} service",
                "adapter": "{{package_name}}",
            }

        try:
            # Test connectivity with a simple request
            await self._client.get("/health")

            status = {
                "status": "healthy",
                "adapter": "{{package_name}}",
                "base_url": self._config.base_url,
                "api_version": self._config.api_version,
            }

            # Add circuit breaker status
            if self._circuit_breaker:
                status["circuit_breaker"] = {
                    "state": self._circuit_breaker.state,
                    "failure_count": self._circuit_breaker.failure_count,
                }

            return status

        except Exception as e:
            logger.error("Health check failed", error=str(e))
            return {
                "status": "unhealthy",
                "reason": f"Health check failed: {str(e)}",
                "adapter": "{{package_name}}",
            }

    async def request(
        self,
        method: str,
        path: str,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Make HTTP request to {{package_name}} API.

        Args:
            method: HTTP method (GET, POST, PUT, DELETE, etc.)
            path: API endpoint path
            **kwargs: Additional request parameters

        Returns:
            Response data

        Raises:
            ConnectionError: If not connected to service
            httpx.HTTPError: For HTTP errors
        """
        if not self._is_connected or not self._client:
            raise ConnectionError("Not connected to {{package_name}} service")

        # Apply rate limiting
        if self._rate_limiter:
            await self._rate_limiter.acquire()

        # Use circuit breaker if enabled
        if self._circuit_breaker:
            return await self._circuit_breaker.call(
                self._make_request, method, path, **kwargs
            )
        else:
            return await self._make_request(method, path, **kwargs)

    async def request_with_retry(
        self,
        method: str,
        path: str,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Make HTTP request with automatic retry logic."""

        @retry(
            stop=stop_after_attempt(self._config.max_retries),
            wait=wait_exponential(
                multiplier=self._config.backoff_factor,
                min=1,
                max=60,
            ),
        )
        async def _request_with_retry():
            return await self.request(method, path, **kwargs)

        return await _request_with_retry()

    async def get(self, path: str, **kwargs: Any) -> Dict[str, Any]:
        """Make GET request."""
        return await self.request("GET", path, **kwargs)

    async def post(self, path: str, **kwargs: Any) -> Dict[str, Any]:
        """Make POST request."""
        return await self.request("POST", path, **kwargs)

    async def put(self, path: str, **kwargs: Any) -> Dict[str, Any]:
        """Make PUT request."""
        return await self.request("PUT", path, **kwargs)

    async def delete(self, path: str, **kwargs: Any) -> Dict[str, Any]:
        """Make DELETE request."""
        return await self.request("DELETE", path, **kwargs)

    async def patch(self, path: str, **kwargs: Any) -> Dict[str, Any]:
        """Make PATCH request."""
        return await self.request("PATCH", path, **kwargs)

    async def _make_request(
        self,
        method: str,
        path: str,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Internal method to make HTTP request."""
        if not self._client:
            raise ConnectionError("Client not initialized")

        logger.debug(
            "Making {{package_name}} API request",
            method=method,
            path=path,
        )

        try:
            response = await self._client.request(method, path, **kwargs)

            logger.debug(
                "{{package_name}} API request successful",
                method=method,
                path=path,
                status_code=response.get("status_code"),
            )

            return response

        except Exception as e:
            logger.error(
                "{{package_name}} API request failed",
                method=method,
                path=path,
                error=str(e),
            )
            raise

    async def get_metrics(self) -> Dict[str, Any]:
        """Get adapter metrics."""
        metrics = {
            "adapter": "{{package_name}}",
            "connected": self._is_connected,
        }

        if self._circuit_breaker:
            metrics["circuit_breaker"] = {
                "state": self._circuit_breaker.state,
                "failure_count": self._circuit_breaker.failure_count,
                "last_failure_time": self._circuit_breaker.last_failure_time,
            }

        if self._rate_limiter:
            metrics["rate_limiter"] = {
                "requests_made": self._rate_limiter.requests_made,
                "requests_remaining": self._rate_limiter.requests_remaining,
            }

        if self._client:
            client_metrics = await self._client.get_metrics()
            metrics["client"] = client_metrics

        return metrics
