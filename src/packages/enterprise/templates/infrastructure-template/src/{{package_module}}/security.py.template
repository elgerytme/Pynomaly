"""Security infrastructure for {{package_title}}."""

import hashlib
import secrets
import time
from typing import Any, Dict, List, Optional
from cryptography.fernet import Fernet
import jwt
import structlog
from enterprise_core import InfrastructureComponent
from .config import {{package_module|title}}Config


logger = structlog.get_logger(__name__)


class {{package_module|title}}Security(InfrastructureComponent):
    """{{package_title}} security component."""

    def __init__(self, config: {{package_module|title}}Config) -> None:
        super().__init__(config)
        self._config = config
        self._encryption_key: Optional[bytes] = None
        self._fernet: Optional[Fernet] = None
        self._failed_attempts: Dict[str, List[float]] = {}
        self._blocked_ips: Dict[str, float] = {}

    async def start(self) -> None:
        """Start security infrastructure."""
        logger.info("Starting {{package_name}} security")

        # Initialize encryption
        if self._config.encryption_key:
            self._encryption_key = self._config.encryption_key.encode()
            self._fernet = Fernet(self._encryption_key)
        else:
            # Generate a new key if none provided
            self._encryption_key = Fernet.generate_key()
            self._fernet = Fernet(self._encryption_key)
            logger.warning(
                "No encryption key provided, generated new key",
                key=self._encryption_key.decode()
            )

        self._is_running = True
        logger.info("{{package_name}} security started")

    async def stop(self) -> None:
        """Stop security infrastructure."""
        logger.info("Stopping {{package_name}} security")

        self._is_running = False
        logger.info("{{package_name}} security stopped")

    def encrypt_data(self, data: str) -> str:
        """Encrypt sensitive data."""
        if not self._fernet:
            raise RuntimeError("Security component not started")

        encrypted_data = self._fernet.encrypt(data.encode())
        return encrypted_data.decode()

    def decrypt_data(self, encrypted_data: str) -> str:
        """Decrypt sensitive data."""
        if not self._fernet:
            raise RuntimeError("Security component not started")

        decrypted_data = self._fernet.decrypt(encrypted_data.encode())
        return decrypted_data.decode()

    def hash_password(self, password: str, salt: Optional[str] = None) -> Dict[str, str]:
        """Hash a password with salt."""
        if salt is None:
            salt = secrets.token_hex(16)

        # Use PBKDF2 for password hashing
        password_hash = hashlib.pbkdf2_hmac(
            "sha256",
            password.encode(),
            salt.encode(),
            100000,  # iterations
        )

        return {
            "hash": password_hash.hex(),
            "salt": salt,
            "algorithm": "pbkdf2_sha256",
            "iterations": 100000,
        }

    def verify_password(self, password: str, stored_hash: Dict[str, str]) -> bool:
        """Verify a password against stored hash."""
        computed_hash = hashlib.pbkdf2_hmac(
            "sha256",
            password.encode(),
            stored_hash["salt"].encode(),
            stored_hash.get("iterations", 100000),
        )

        return secrets.compare_digest(
            computed_hash.hex(),
            stored_hash["hash"]
        )

    def create_jwt_token(
        self,
        payload: Dict[str, Any],
        expires_in: int = 3600,
    ) -> str:
        """Create a JWT token."""
        if not self._config.jwt_secret:
            raise RuntimeError("JWT secret not configured")

        # Add expiration time
        payload["exp"] = time.time() + expires_in
        payload["iat"] = time.time()

        token = jwt.encode(
            payload,
            self._config.jwt_secret,
            algorithm=self._config.jwt_algorithm
        )

        return token

    def verify_jwt_token(self, token: str) -> Dict[str, Any]:
        """Verify and decode a JWT token."""
        if not self._config.jwt_secret:
            raise RuntimeError("JWT secret not configured")

        try:
            payload = jwt.decode(
                token,
                self._config.jwt_secret,
                algorithms=[self._config.jwt_algorithm]
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise ValueError("Token has expired")
        except jwt.InvalidTokenError:
            raise ValueError("Invalid token")

    def generate_api_key(self, length: int = 32) -> str:
        """Generate a secure API key."""
        return secrets.token_urlsafe(length)

    def generate_session_token(self) -> str:
        """Generate a secure session token."""
        return secrets.token_urlsafe(32)

    def check_rate_limit(
        self,
        identifier: str,
        max_attempts: int = 5,
        window_minutes: int = 15,
    ) -> bool:
        """Check if identifier is within rate limits."""
        current_time = time.time()
        window_start = current_time - (window_minutes * 60)

        # Clean old attempts
        if identifier in self._failed_attempts:
            self._failed_attempts[identifier] = [
                attempt_time for attempt_time in self._failed_attempts[identifier]
                if attempt_time > window_start
            ]

        # Count recent attempts
        recent_attempts = len(self._failed_attempts.get(identifier, []))

        return recent_attempts < max_attempts

    def record_failed_attempt(self, identifier: str) -> None:
        """Record a failed authentication attempt."""
        current_time = time.time()

        if identifier not in self._failed_attempts:
            self._failed_attempts[identifier] = []

        self._failed_attempts[identifier].append(current_time)

        logger.warning(
            "Failed authentication attempt recorded",
            identifier=identifier,
            total_attempts=len(self._failed_attempts[identifier])
        )

    def is_blocked(self, identifier: str) -> bool:
        """Check if identifier is blocked."""
        if identifier not in self._blocked_ips:
            return False

        # Check if block has expired
        current_time = time.time()
        block_expires = self._blocked_ips[identifier]

        if current_time > block_expires:
            del self._blocked_ips[identifier]
            return False

        return True

    def block_identifier(
        self,
        identifier: str,
        duration_minutes: int = 60,
    ) -> None:
        """Block an identifier for a specified duration."""
        block_expires = time.time() + (duration_minutes * 60)
        self._blocked_ips[identifier] = block_expires

        logger.warning(
            "Identifier blocked",
            identifier=identifier,
            duration_minutes=duration_minutes
        )

    def validate_input(self, data: str, max_length: int = 1000) -> bool:
        """Validate input data for security issues."""
        # Check length
        if len(data) > max_length:
            return False

        # Check for common injection patterns
        dangerous_patterns = [
            "<script",
            "javascript:",
            "data:text/html",
            "vbscript:",
            "onload=",
            "onerror=",
            "eval(",
            "exec(",
            "__import__",
        ]

        data_lower = data.lower()
        for pattern in dangerous_patterns:
            if pattern in data_lower:
                logger.warning(
                    "Potentially dangerous input detected",
                    pattern=pattern,
                    data_preview=data[:100]
                )
                return False

        return True

    def sanitize_filename(self, filename: str) -> str:
        """Sanitize a filename for security."""
        # Remove path traversal attempts
        filename = filename.replace("..", "").replace("/", "").replace("\\\\", "")

        # Keep only alphanumeric, dots, hyphens, and underscores
        allowed_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_"
        sanitized = "".join(c for c in filename if c in allowed_chars)

        # Ensure filename is not empty and not too long
        if not sanitized:
            sanitized = "unknown_file"

        if len(sanitized) > 255:
            sanitized = sanitized[:255]

        return sanitized

    def get_security_headers(self) -> Dict[str, str]:
        """Get recommended security headers."""
        return {
            "X-Content-Type-Options": "nosniff",
            "X-Frame-Options": "DENY",
            "X-XSS-Protection": "1; mode=block",
            "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
            "Content-Security-Policy": "default-src 'self'",
            "Referrer-Policy": "strict-origin-when-cross-origin",
        }

    async def health_check(self) -> Dict[str, Any]:
        """Check security component health."""
        return {
            "status": "healthy" if self._is_running else "unhealthy",
            "encryption_available": self._fernet is not None,
            "jwt_configured": self._config.jwt_secret is not None,
            "active_blocks": len(self._blocked_ips),
            "tracked_attempts": len(self._failed_attempts),
        }

    def get_metrics(self) -> Dict[str, Any]:
        """Get security metrics."""
        return {
            "blocked_identifiers": len(self._blocked_ips),
            "failed_attempts_tracked": len(self._failed_attempts),
            "total_failed_attempts": sum(
                len(attempts) for attempts in self._failed_attempts.values()
            ),
        }
