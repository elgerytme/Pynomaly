"""Alert handlers for performance monitoring system."""

import asyncio
import json
import logging
import smtplib
from datetime import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, Any, Optional
from pathlib import Path
import aiohttp
import os

from .performance_alerts import PerformanceAlert, AlertSeverity

logger = logging.getLogger(__name__)


class EmailAlertHandler:
    """Email alert handler for performance monitoring."""
    
    def __init__(self, smtp_config: Dict[str, Any]):
        """Initialize email handler with SMTP configuration."""
        self.smtp_server = smtp_config.get('smtp_server', 'smtp.gmail.com')
        self.smtp_port = smtp_config.get('smtp_port', 587)
        self.smtp_username = smtp_config.get('smtp_username')
        self.smtp_password = smtp_config.get('smtp_password')
        self.from_email = smtp_config.get('from_email', self.smtp_username)
        self.to_emails = smtp_config.get('to_emails', [])
        self.enabled = smtp_config.get('enabled', False)
        
        # Email templates
        self.email_templates = {
            AlertSeverity.CRITICAL: {
                'subject_prefix': '🚨 CRITICAL ALERT',
                'color': '#DC2626',
                'priority': 'high'
            },
            AlertSeverity.HIGH: {
                'subject_prefix': '🔥 HIGH ALERT',
                'color': '#EA580C',
                'priority': 'high'
            },
            AlertSeverity.MEDIUM: {
                'subject_prefix': '⚠️ MEDIUM ALERT',
                'color': '#F59E0B',
                'priority': 'normal'
            },
            AlertSeverity.LOW: {
                'subject_prefix': '💡 LOW ALERT',
                'color': '#3B82F6',
                'priority': 'normal'
            }
        }
    
    def __call__(self, alert: PerformanceAlert):
        """Handle alert by sending email."""
        if not self.enabled or not self.smtp_username or not self.to_emails:
            logger.warning("Email alerts not configured properly")
            return
        
        try:
            self._send_email(alert)
            logger.info(f"Email alert sent for {alert.alert_id}")
        except Exception as e:
            logger.error(f"Failed to send email alert: {e}")
    
    def _send_email(self, alert: PerformanceAlert):
        """Send email for alert."""
        template = self.email_templates.get(alert.severity, self.email_templates[AlertSeverity.MEDIUM])
        
        # Create message
        msg = MIMEMultipart('alternative')
        msg['Subject'] = f"{template['subject_prefix']} - {alert.message}"
        msg['From'] = self.from_email
        msg['To'] = ', '.join(self.to_emails)
        
        if template['priority'] == 'high':
            msg['X-Priority'] = '1'
            msg['X-MSMail-Priority'] = 'High'
        
        # Create text and HTML versions
        text_content = self._create_text_email(alert)
        html_content = self._create_html_email(alert, template)
        
        # Attach parts
        part1 = MIMEText(text_content, 'plain')
        part2 = MIMEText(html_content, 'html')
        
        msg.attach(part1)
        msg.attach(part2)
        
        # Send email
        with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
            server.starttls()
            server.login(self.smtp_username, self.smtp_password)
            server.send_message(msg)
    
    def _create_text_email(self, alert: PerformanceAlert) -> str:
        """Create plain text email content."""
        return f"""
Performance Alert: {alert.message}

Alert Details:
- Alert ID: {alert.alert_id}
- Severity: {alert.severity.value.upper()}
- Metric Type: {alert.metric_type.value}
- Current Value: {alert.current_value}
- Threshold: {alert.threshold_value}
- Triggered At: {alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S')}

Metadata:
{json.dumps(alert.metadata, indent=2)}

This alert was generated by the Pynomaly performance monitoring system.
"""
    
    def _create_html_email(self, alert: PerformanceAlert, template: Dict[str, Any]) -> str:
        """Create HTML email content."""
        return f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }}
        .alert-container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
        .alert-header {{ background-color: {template['color']}; color: white; padding: 20px; border-radius: 8px 8px 0 0; }}
        .alert-body {{ background-color: #f9fafb; padding: 20px; border: 1px solid #e5e7eb; border-radius: 0 0 8px 8px; }}
        .alert-detail {{ margin-bottom: 15px; }}
        .alert-detail strong {{ color: #374151; }}
        .metadata {{ background-color: #f3f4f6; padding: 15px; border-radius: 4px; font-family: monospace; font-size: 12px; }}
        .footer {{ text-align: center; margin-top: 30px; font-size: 12px; color: #6b7280; }}
    </style>
</head>
<body>
    <div class="alert-container">
        <div class="alert-header">
            <h2 style="margin: 0;">Performance Alert</h2>
            <p style="margin: 10px 0 0 0;">{alert.message}</p>
        </div>
        <div class="alert-body">
            <div class="alert-detail">
                <strong>Alert ID:</strong> {alert.alert_id}
            </div>
            <div class="alert-detail">
                <strong>Severity:</strong> {alert.severity.value.upper()}
            </div>
            <div class="alert-detail">
                <strong>Metric Type:</strong> {alert.metric_type.value.replace('_', ' ').title()}
            </div>
            <div class="alert-detail">
                <strong>Current Value:</strong> {alert.current_value}
            </div>
            <div class="alert-detail">
                <strong>Threshold:</strong> {alert.threshold_value}
            </div>
            <div class="alert-detail">
                <strong>Triggered At:</strong> {alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S')}
            </div>
            
            <h3>Metadata</h3>
            <div class="metadata">
                {json.dumps(alert.metadata, indent=2)}
            </div>
        </div>
        <div class="footer">
            <p>This alert was generated by the Pynomaly performance monitoring system.</p>
        </div>
    </div>
</body>
</html>
"""


class SlackAlertHandler:
    """Slack alert handler for performance monitoring."""
    
    def __init__(self, webhook_url: str, channel: str = None):
        """Initialize Slack handler."""
        self.webhook_url = webhook_url
        self.channel = channel
        self.enabled = bool(webhook_url)
        
        # Slack emoji mapping
        self.emoji_map = {
            AlertSeverity.CRITICAL: ':rotating_light:',
            AlertSeverity.HIGH: ':fire:',
            AlertSeverity.MEDIUM: ':warning:',
            AlertSeverity.LOW: ':bulb:'
        }
        
        # Color mapping
        self.color_map = {
            AlertSeverity.CRITICAL: '#DC2626',
            AlertSeverity.HIGH: '#EA580C',
            AlertSeverity.MEDIUM: '#F59E0B',
            AlertSeverity.LOW: '#3B82F6'
        }
    
    def __call__(self, alert: PerformanceAlert):
        """Handle alert by sending to Slack."""
        if not self.enabled:
            logger.warning("Slack alerts not configured")
            return
        
        asyncio.create_task(self._send_slack_message(alert))
    
    async def _send_slack_message(self, alert: PerformanceAlert):
        """Send Slack message for alert."""
        try:
            payload = self._create_slack_payload(alert)
            
            async with aiohttp.ClientSession() as session:
                async with session.post(self.webhook_url, json=payload) as response:
                    if response.status == 200:
                        logger.info(f"Slack alert sent for {alert.alert_id}")
                    else:
                        logger.error(f"Failed to send Slack alert: {response.status}")
        except Exception as e:
            logger.error(f"Failed to send Slack alert: {e}")
    
    def _create_slack_payload(self, alert: PerformanceAlert) -> Dict[str, Any]:
        """Create Slack message payload."""
        emoji = self.emoji_map.get(alert.severity, ':warning:')
        color = self.color_map.get(alert.severity, '#F59E0B')
        
        # Create attachment
        attachment = {
            "color": color,
            "title": f"{emoji} {alert.severity.value.upper()} Alert",
            "text": alert.message,
            "fields": [
                {
                    "title": "Alert ID",
                    "value": alert.alert_id,
                    "short": True
                },
                {
                    "title": "Metric Type",
                    "value": alert.metric_type.value.replace('_', ' ').title(),
                    "short": True
                },
                {
                    "title": "Current Value",
                    "value": str(alert.current_value),
                    "short": True
                },
                {
                    "title": "Threshold",
                    "value": str(alert.threshold_value),
                    "short": True
                },
                {
                    "title": "Triggered At",
                    "value": alert.triggered_at.strftime('%Y-%m-%d %H:%M:%S'),
                    "short": True
                }
            ],
            "footer": "Pynomaly Performance Monitoring",
            "ts": int(alert.triggered_at.timestamp())
        }
        
        # Add metadata if available
        if alert.metadata:
            metadata_text = "\n".join([f"• {k}: {v}" for k, v in alert.metadata.items()])
            attachment["fields"].append({
                "title": "Metadata",
                "value": metadata_text,
                "short": False
            })
        
        payload = {
            "attachments": [attachment]
        }
        
        if self.channel:
            payload["channel"] = self.channel
        
        return payload


class WebhookAlertHandler:
    """Generic webhook alert handler."""
    
    def __init__(self, webhook_url: str, headers: Dict[str, str] = None, auth: Dict[str, str] = None):
        """Initialize webhook handler."""
        self.webhook_url = webhook_url
        self.headers = headers or {'Content-Type': 'application/json'}
        self.auth = auth
        self.enabled = bool(webhook_url)
    
    def __call__(self, alert: PerformanceAlert):
        """Handle alert by sending webhook."""
        if not self.enabled:
            logger.warning("Webhook alerts not configured")
            return
        
        asyncio.create_task(self._send_webhook(alert))
    
    async def _send_webhook(self, alert: PerformanceAlert):
        """Send webhook for alert."""
        try:
            payload = self._create_webhook_payload(alert)
            
            async with aiohttp.ClientSession() as session:
                kwargs = {
                    'json': payload,
                    'headers': self.headers
                }
                
                # Add authentication if configured
                if self.auth:
                    if self.auth.get('type') == 'bearer':
                        kwargs['headers']['Authorization'] = f"Bearer {self.auth['token']}"
                    elif self.auth.get('type') == 'basic':
                        auth = aiohttp.BasicAuth(self.auth['username'], self.auth['password'])
                        kwargs['auth'] = auth
                
                async with session.post(self.webhook_url, **kwargs) as response:
                    if response.status == 200:
                        logger.info(f"Webhook alert sent for {alert.alert_id}")
                    else:
                        logger.error(f"Failed to send webhook alert: {response.status}")
        except Exception as e:
            logger.error(f"Failed to send webhook alert: {e}")
    
    def _create_webhook_payload(self, alert: PerformanceAlert) -> Dict[str, Any]:
        """Create webhook payload."""
        return {
            "alert_id": alert.alert_id,
            "severity": alert.severity.value,
            "metric_type": alert.metric_type.value,
            "message": alert.message,
            "current_value": alert.current_value,
            "threshold_value": alert.threshold_value,
            "triggered_at": alert.triggered_at.isoformat(),
            "resolved_at": alert.resolved_at.isoformat() if alert.resolved_at else None,
            "tags": alert.tags,
            "metadata": alert.metadata,
            "source": "pynomaly-performance-monitoring"
        }


class DiscordAlertHandler:
    """Discord alert handler for performance monitoring."""
    
    def __init__(self, webhook_url: str):
        """Initialize Discord handler."""
        self.webhook_url = webhook_url
        self.enabled = bool(webhook_url)
        
        # Discord color mapping (decimal values)
        self.color_map = {
            AlertSeverity.CRITICAL: 14495300,  # Red
            AlertSeverity.HIGH: 15826432,      # Orange
            AlertSeverity.MEDIUM: 16766720,    # Yellow
            AlertSeverity.LOW: 3901635         # Blue
        }
    
    def __call__(self, alert: PerformanceAlert):
        """Handle alert by sending to Discord."""
        if not self.enabled:
            logger.warning("Discord alerts not configured")
            return
        
        asyncio.create_task(self._send_discord_message(alert))
    
    async def _send_discord_message(self, alert: PerformanceAlert):
        """Send Discord message for alert."""
        try:
            payload = self._create_discord_payload(alert)
            
            async with aiohttp.ClientSession() as session:
                async with session.post(self.webhook_url, json=payload) as response:
                    if response.status == 204:  # Discord returns 204 for success
                        logger.info(f"Discord alert sent for {alert.alert_id}")
                    else:
                        logger.error(f"Failed to send Discord alert: {response.status}")
        except Exception as e:
            logger.error(f"Failed to send Discord alert: {e}")
    
    def _create_discord_payload(self, alert: PerformanceAlert) -> Dict[str, Any]:
        """Create Discord message payload."""
        color = self.color_map.get(alert.severity, 16766720)
        
        # Create embed
        embed = {
            "title": f"{alert.severity.value.upper()} Performance Alert",
            "description": alert.message,
            "color": color,
            "timestamp": alert.triggered_at.isoformat(),
            "fields": [
                {
                    "name": "Alert ID",
                    "value": alert.alert_id,
                    "inline": True
                },
                {
                    "name": "Metric Type",
                    "value": alert.metric_type.value.replace('_', ' ').title(),
                    "inline": True
                },
                {
                    "name": "Current Value",
                    "value": str(alert.current_value),
                    "inline": True
                },
                {
                    "name": "Threshold",
                    "value": str(alert.threshold_value),
                    "inline": True
                }
            ],
            "footer": {
                "text": "Pynomaly Performance Monitoring"
            }
        }
        
        # Add metadata if available
        if alert.metadata:
            metadata_text = "\n".join([f"**{k}**: {v}" for k, v in alert.metadata.items()])
            embed["fields"].append({
                "name": "Metadata",
                "value": metadata_text,
                "inline": False
            })
        
        return {
            "embeds": [embed]
        }


class FileAlertHandler:
    """File-based alert handler for logging alerts to files."""
    
    def __init__(self, log_file: str = "alerts.log", max_file_size: int = 10_000_000):
        """Initialize file handler."""
        self.log_file = Path(log_file)
        self.max_file_size = max_file_size
        self.enabled = True
        
        # Create log directory if it doesn't exist
        self.log_file.parent.mkdir(parents=True, exist_ok=True)
    
    def __call__(self, alert: PerformanceAlert):
        """Handle alert by logging to file."""
        if not self.enabled:
            return
        
        try:
            self._write_alert_to_file(alert)
            logger.info(f"Alert logged to file: {alert.alert_id}")
        except Exception as e:
            logger.error(f"Failed to log alert to file: {e}")
    
    def _write_alert_to_file(self, alert: PerformanceAlert):
        """Write alert to log file."""
        # Check file size and rotate if necessary
        if self.log_file.exists() and self.log_file.stat().st_size > self.max_file_size:
            self._rotate_log_file()
        
        # Create alert entry
        alert_entry = {
            "timestamp": alert.triggered_at.isoformat(),
            "alert_id": alert.alert_id,
            "severity": alert.severity.value,
            "metric_type": alert.metric_type.value,
            "message": alert.message,
            "current_value": alert.current_value,
            "threshold_value": alert.threshold_value,
            "resolved_at": alert.resolved_at.isoformat() if alert.resolved_at else None,
            "tags": alert.tags,
            "metadata": alert.metadata
        }
        
        # Write to file
        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(json.dumps(alert_entry) + '\n')
    
    def _rotate_log_file(self):
        """Rotate log file when it gets too large."""
        if not self.log_file.exists():
            return
        
        # Create backup filename with timestamp
        backup_name = f"{self.log_file.stem}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        backup_path = self.log_file.parent / backup_name
        
        # Move current file to backup
        self.log_file.rename(backup_path)
        
        logger.info(f"Log file rotated: {backup_path}")


class DatabaseAlertHandler:
    """Database alert handler for storing alerts in database."""
    
    def __init__(self, db_url: str = None):
        """Initialize database handler."""
        self.db_url = db_url or os.getenv('DATABASE_URL')
        self.enabled = bool(self.db_url)
        self.table_name = 'performance_alerts'
    
    def __call__(self, alert: PerformanceAlert):
        """Handle alert by storing in database."""
        if not self.enabled:
            logger.warning("Database alerts not configured")
            return
        
        asyncio.create_task(self._store_alert_in_database(alert))
    
    async def _store_alert_in_database(self, alert: PerformanceAlert):
        """Store alert in database."""
        try:
            # This is a placeholder implementation
            # In a real implementation, you would use your preferred database library
            # (e.g., SQLAlchemy, asyncpg, etc.)
            
            logger.info(f"Alert stored in database: {alert.alert_id}")
            
            # Example structure:
            # INSERT INTO performance_alerts (
            #     alert_id, severity, metric_type, message, current_value,
            #     threshold_value, triggered_at, resolved_at, tags, metadata
            # ) VALUES (...)
            
        except Exception as e:
            logger.error(f"Failed to store alert in database: {e}")


# Alert handler factory
def create_alert_handlers(config: Dict[str, Any]) -> list:
    """Create alert handlers based on configuration."""
    handlers = []
    
    # Console handler (always enabled)
    from .performance_alerts import console_alert_handler
    handlers.append(console_alert_handler)
    
    # Email handler
    if config.get('email', {}).get('enabled', False):
        email_handler = EmailAlertHandler(config['email'])
        handlers.append(email_handler)
    
    # Slack handler
    if config.get('slack', {}).get('webhook_url'):
        slack_handler = SlackAlertHandler(
            webhook_url=config['slack']['webhook_url'],
            channel=config['slack'].get('channel')
        )
        handlers.append(slack_handler)
    
    # Discord handler
    if config.get('discord', {}).get('webhook_url'):
        discord_handler = DiscordAlertHandler(
            webhook_url=config['discord']['webhook_url']
        )
        handlers.append(discord_handler)
    
    # Webhook handler
    if config.get('webhook', {}).get('url'):
        webhook_handler = WebhookAlertHandler(
            webhook_url=config['webhook']['url'],
            headers=config['webhook'].get('headers', {}),
            auth=config['webhook'].get('auth')
        )
        handlers.append(webhook_handler)
    
    # File handler
    if config.get('file', {}).get('enabled', True):
        file_handler = FileAlertHandler(
            log_file=config['file'].get('log_file', 'logs/alerts.log'),
            max_file_size=config['file'].get('max_file_size', 10_000_000)
        )
        handlers.append(file_handler)
    
    # Database handler
    if config.get('database', {}).get('enabled', False):
        database_handler = DatabaseAlertHandler(
            db_url=config['database'].get('url')
        )
        handlers.append(database_handler)
    
    return handlers